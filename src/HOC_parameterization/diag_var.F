! $Id: diag_var.F,v 1.34 2008-03-22 19:17:23 griffinb Exp $
#define SCLR_THETA 1
#define SCLR_RT 2
!-----------------------------------------------------------------------
      module diagnose_variances

!     Description:
!     Contains the subroutine diag_var and ancillary functions.
!-----------------------------------------------------------------------

        implicit none

        public :: diag_var

        private :: diag_var_lhs, diag_var_solve, 
     .             diag_var_rhs, diag_var_uv_rhs

        contains
!-----------------------------------------------------------------------
        subroutine diag_var( taum, wmm, rtm, wprtp, 
     .                       thlm, wpthlp, wpthvp, um, vm,
     .                       wp2, wp3, upwp, vpwp, Scm, Skwm, Kht,
     .                       rtp2, thlp2, rtpthlp,
     .                       up2, vp2,
     .                       liter, dt, isValid,
     .                       sclrm, wpsclrp, sclrp2,        ! optional
     .                       sclrprtp, sclrpthlp )          ! optional
!       Description:
!       Subprogram to diagnose variances by solving steady-state equations

!       References:
!       Eqn. 13, 14, 15  on p. 3545 of 
!       ``A PDF-Based Model for Boundary Layer Clouds. Part I:
!         Method and Model Description'' Golaz, et al. (2002)
!       JAS, Vol. 59, pp. 3540--3551.

!      See also
!      ``Equations for HOC'', Section 4:
!      /Steady-state solution for the variances/ 
!-----------------------------------------------------------------------

        use constants
        use parameters, 
     .    only: C2, C2b, C2c, C2rt, C2thl, C2rtthl, c_K2, nu2, nu9, 
     .          c_Ksqd, beta, C4, C14, C5, T0
        use grid_class
        use lapack_wrap, only: tridag_solve
#ifdef STATS
        use stats_hoc
#endif /*STATS*/
       
        implicit none

        ! Input variables
        real, intent(in), dimension(gr%nnzp) :: 
     .  taum,  ! Tau on moment. grid            [s]
     .  wmm,   ! w wind on m                    [m/s]
     .  rtm,   ! Total water mixing ratio       [kg/kg]
     .  wprtp, ! w' r_t'                        [(m kg)/(s kg)]
     .  thlm,  ! Liquid potential temp.         [K]
     .  wpthlp,! w' th_l'                       [(m K)/s]
     .  wpthvp,! w' th_v'                       [(m K)/s]
     .  um,    ! u wind                         [m/s]
     .  vm,    ! v wind                         [m/s]
     .  wp2,   ! w'^2                           [m^2/s^2]
     .  wp3,   ! w'^3                           [m^3/s^3]
     .  upwp,  ! u'w'                           [m^2/s^2]
     .  vpwp,  ! u'w'                           [m^2/s^2]
     .  Scm,   ! Sc on moment. grid             [-]
     .  Skwm,  ! Skw on moment. grid            [-]
     .  Kht    ! Eddy diffusivity on t-lev.     [m^2/s]

        logical, intent(in) :: liter ! Whether variances are prognostic

        real, intent(in) :: dt ! Timestep       [s]

        ! Input/Output variables
        ! An attribute of (inout) is also needed to import the
        ! value of the variances at the surface.  Brian.  12/18/05.
        real, intent(inout), dimension(gr%nnzp) :: 
     .  rtp2,   ! r_t'^2                        [(kg/kg)^2]
     .  thlp2,  ! th_l'^2                       [K^2]
     .  rtpthlp,! r_t' th_l'                    [(kg K)/kg]
     .  up2,    ! u'^2                          [m^2/s^2]
     .  vp2     ! v'^2                          [m^2/s^2]

        ! Output variable for singular matrices

        logical, intent(out) :: isValid

        ! Passive scalar input (optional)
        real, optional, intent(in), dimension(gr%nnzp, sclr_dim) :: 
     .  sclrm, wpsclrp

        ! Passive scalar output (optional)
        real, optional, intent(out), dimension(gr%nnzp, sclr_dim) :: 
     .  sclrp2, sclrprtp, sclrpthlp

        ! Local Variables
        real, dimension(gr%nnzp) ::
     .  C2sclr_1d, C2rt_1d, C2thl_1d, C2rtthl_1d, C4_C14_1d

        real, dimension(gr%nnzp) :: 
     .  a1 ! a1; See eqn. 20 in `Equations for HOC'

        real, dimension(3,gr%nnzp) :: 
     .  lhs ! Tridiagonal matrix

        real, dimension(gr%nnzp,1) ::
     .  rhs ! RHS vector of Tridiagonal matrix

        real, dimension(gr%nnzp,sclr_dim*3) :: 
     .  sclr_rhs,     ! RHS of scalar tridiagonal system
     .  sclr_solution ! Solution to tridiagonal system

        logical, dimension(5+1) ::
     .  Valid_arr

        ! Eddy Diffusion for Variances and Covariances.
        real, dimension(gr%nnzp) :: Kw2   ! [m^2/s]

        ! Variables used for adding (xapxbp)^2: 3-point average
        ! diffusion coefficient.
        real, dimension(gr%nnzp) ::
     .  rtp2_zt,
     .  thlp2_zt,
     .  rtpthlp_zt,
     .  rtp2_zt_sqd_3pt,
     .  thlp2_zt_sqd_3pt,
     .  rtpthlp_zt_sqd_3pt,
     .  Kw2_rtp2,
     .  Kw2_thlp2,
     .  Kw2_rtpthlp

        ! wtol_sqd = the square of the minimum threshold on w,
        !     [wtol_sqd] = m^2 s^{-2}.  Vince Larson 11 Mar 2008.
        real :: wtol_sqd

        logical :: scalar_calc

        ! Loop indices
        integer :: i
        integer :: k, km1, kp1


!-----------------------------------------------------------------------
#ifdef SINGLE_C2_SKW
        ! Use a single value of C2 for all equations.
        C2rt_1d(1:gr%nnzp) 
     .  = C2b + (C2-C2b) *exp( -0.5 * (Skwm(1:gr%nnzp)/C2c)**2 )

        C2thl_1d   = C2rt_1d
        C2rtthl_1d = C2rt_1d

        C2sclr_1d  = C2rt_1d
#else
        ! Use 3 different values of C2 for rtp2, thlp2, rtpthlp.
        C2rt_1d(1:gr%nnzp)    = C2rt
        C2thl_1d(1:gr%nnzp)   = C2thl
        C2rtthl_1d(1:gr%nnzp) = C2rtthl

        C2sclr_1d(1:gr%nnzp)  = C2rt  ! Use rt value for now
#endif
        C4_C14_1d(1:gr%nnzp) = 2.0/3.0 * C4 + ( 1.0/3.0 * C14 )

        ! Are we solving for a passive scalar as well?

        if ( present( sclrm ) .and. present( wpsclrp ) .and.
     .       present( sclrp2 ) .and. present( sclrprtp ) .and.
     .       present( sclrpthlp ) ) then

          scalar_calc = .true.

        else
          scalar_calc = .false.

        end if

        ! Define a1
        a1(1:gr%nnzp) = 1.0 / ( 1.0 - Scm(1:gr%nnzp) )


        ! wtol_sqd = the square of the minimum threshold on w,
        !     [wtol_sqd] = m^2 s^{-2}.  Vince Larson 11 Mar 2008.
        wtol_sqd = wtol * wtol

#ifdef STATS
        if ( lstats_samp ) then

          if ( irtp2_bt > 0 ) then
            zm%x(:,irtp2_bt) = zm%x(:,irtp2_bt) - rtp2 / dt
          end if

          if ( ithlp2_bt > 0 ) then
            zm%x(:,ithlp2_bt) = zm%x(:,ithlp2_bt) - thlp2 / dt
          end if

          if ( irtpthlp_bt > 0 ) then
            zm%x(:,irtpthlp_bt) = zm%x(:,irtpthlp_bt) - rtpthlp / dt
          end if

          if ( ivp2_bt > 0 ) then
            zm%x(:,ivp2_bt) = zm%x(:,ivp2_bt) - vp2 / dt
          end if

          if ( iup2_bt > 0 ) then
            zm%x(:,iup2_bt) = zm%x(:,iup2_bt) - up2 / dt
          end if

        end if
#endif
        ! Initialize tridiagonal solutions to valid

        Valid_arr(:) = .true.

        ! (xapxbp)^2: 3-point average diffusion coefficient.

        rtp2_zt    = zm2zt(rtp2)
        thlp2_zt   = zm2zt(thlp2)
        rtpthlp_zt = zm2zt(rtpthlp)

        do k = 1, gr%nnzp, 1

           km1 = max( k-1, 1 )
           kp1 = min( k+1, gr%nnzp )

           ! Compute the square of rtp2_zt, averaged over 3 points.  26 Jan 2008
           rtp2_zt_sqd_3pt(k) = ( rtp2_zt(km1)**2 + rtp2_zt(k)**2 
     .                           + rtp2_zt(kp1)**2 ) / 3.0
           ! Account for units (kg/kg)**4  Vince Larson 29 Jan 2008
           rtp2_zt_sqd_3pt(k) = 1e12 * rtp2_zt_sqd_3pt(k)  

           ! Compute the square of thlp2_zt, averaged over 3 points.  26 Jan 2008
           thlp2_zt_sqd_3pt(k) = ( thlp2_zt(km1)**2 + thlp2_zt(k)**2 
     .                            + thlp2_zt(kp1)**2 ) / 3.0

           ! Compute the square of rtpthlp_zt, averaged over 3 points.  26 Jan 2008
           rtpthlp_zt_sqd_3pt(k) 
     .          = ( rtpthlp_zt(km1)**2 + rtpthlp_zt(k)**2 
     .             + rtpthlp_zt(kp1)**2 ) / 3.0
           ! Account for units (kg/kg)**2 Vince Larson 29 Jan 2008
           rtpthlp_zt_sqd_3pt(k) = 1e6 * rtpthlp_zt_sqd_3pt(k)

        enddo

        ! Define the Coefficent of Eddy Diffusivity for the 
        ! Variances and Covariances.
        do k = 1, gr%nnzp, 1
           ! Kw2 is used for all variances and covariances in subroutine
           ! diag_var.  The variances and covariances are located on 
           ! momentum levels.  Kw2 is located on thermodynamic levels.
           ! Kw2 = c_K2 * Kht
           Kw2(k) = c_K2 * Kht(k)
           ! Kw2_rtp2 must have units of m^2/s.  Since rtp2_zt_sqd_3pt has 
           ! units of kg^2/kg^2, c_Ksqd is given units of m^2/[ s (kg^2/kg^2) ]
           ! in this case.
           Kw2_rtp2(k)    = Kw2(k) + c_Ksqd * rtp2_zt_sqd_3pt(k) ! Vince Larson increased by c_Ksqd, 29Jan2008
           ! Kw2_thlp2 must have units of m^2/s.  Since thlp2_zt_sqd_3pt has 
           ! units of K^2, c_Ksqd is given units of m^2/[ s K^2 ] in this case.
           Kw2_thlp2(k)   = Kw2(k) + c_Ksqd * thlp2_zt_sqd_3pt(k) ! Vince Larson increased by c_Ksqd, 29Jan2008
           ! Kw2_rtpthlp must have units of m^2/s.  Since rtpthlp_zt_sqd_3pt has
           ! units of K (kg/kg), c_Ksqd is given units of m^2/[ s K (kg/kg) ] 
           ! in this case.
           Kw2_rtpthlp(k) = Kw2(k) + c_Ksqd * rtpthlp_zt_sqd_3pt(k) ! Vince Larson increased by c_Ksqd, 29Jan2008
        enddo

        ! Implicit contributions to term rtp2

!        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2_rtp2, 
     .                     C2rt_1d, nu2, beta, wtol_sqd, dt, liter,
     .                     lhs )

        ! Explicit contributions to rtp2

        call diag_var_rhs( "rtp2", a1, wp2, wp3,
     .                     rtm, rtm, wprtp, wprtp, rtp2,
     .                     dt, beta, wtol_sqd, liter, rhs )
        
        ! Solve the tridiagonal system

        call diag_var_solve( "rtp2", 1, rhs, 
     .                       lhs, rtp2, Valid_arr(1) )

        ! Implicit contributions to term thlp2

!        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2_thlp2, 
     .                     C2thl_1d, nu2, beta, wtol_sqd, dt, liter,
     .                     lhs )

        ! Explicit contributions to thlp2

        call diag_var_rhs( "thlp2", a1, wp2, wp3,
     .                     thlm, thlm, wpthlp, wpthlp, thlp2,
     .                     dt, beta, wtol_sqd, liter, rhs )

        ! Solve the tridiagonal system

        call diag_var_solve( "thlp2", 1, rhs, 
     .                       lhs, thlp2, Valid_arr(2) )

        ! Implicit contributions to term rtpthlp

!        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2_rtpthlp, 
     .                     C2rtthl_1d, nu2, beta, wtol_sqd, dt, liter,
     .                     lhs )

        ! Explicit contributions to rtpthlp

        call diag_var_rhs( "rtpthlp", a1, wp2, wp3,
     .                     rtm, thlm, wprtp, wpthlp, rtpthlp,
     .                     dt, beta, wtol_sqd, liter, rhs )

        ! Solve the tridiagonal system

        call diag_var_solve( "rtpthlp", 1, rhs, 
     .                       lhs, rtpthlp, Valid_arr(3) )

        ! Implicit contributions to term up2

        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
     .                     C4_C14_1d, nu9, beta, wtol_sqd, dt, liter,
     .                     lhs )

        ! Explicit contributions to up2

        call diag_var_uv_rhs
     .       ( "up2", a1, wp2, wp3, wpthvp, taum,
     .         um, vm, upwp, vpwp, up2, vp2, 
     .         dt, C4, C5, C14, beta, T0, wtol_sqd, liter, rhs )

        ! Solve the tridiagonal system

        call diag_var_solve( "up2", 1, rhs,
     .                       lhs, up2, Valid_arr(4) )

        ! Implicit contributions to term vp2

        call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
     .                     C4_C14_1d, nu9, beta, wtol_sqd, dt, liter,
     .                     lhs )

        ! Explicit contributions to vp2

        call diag_var_uv_rhs
     .       ( "vp2", a1, wp2, wp3, wpthvp, taum, 
     .         vm, um, vpwp, upwp, vp2, up2,
     .         dt, C4, C5, C14, beta, T0, wtol_sqd, liter, rhs )


        ! Solve the tridiagonal system

        call diag_var_solve( "vp2", 1, rhs, 
     .                       lhs, vp2, Valid_arr(5) )


#ifdef STATS
        if (lstats_samp .and. irtp2_cl > 0 ) then
          zm%x(:,irtp2_cl) = zm%x(:,irtp2_cl) - rtp2 / dt
        end if
        if (lstats_samp .and. ithlp2_cl > 0 ) then
          zm%x(:,ithlp2_cl) = zm%x(:,ithlp2_cl) - thlp2 / dt
        end if
        if (lstats_samp .and. iup2_cl > 0 ) then
          zm%x(:,iup2_cl) = zm%x(:,iup2_cl) - up2 / dt
        end if
        if (lstats_samp .and. ivp2_cl > 0 ) then
          zm%x(:,ivp2_cl) = zm%x(:,ivp2_cl) - vp2 / dt
        end if
#endif

        ! Clip small and negative values
        ! The surface variances are set elsewhere.  They do not need to be
        ! clipped at the lowest level.  Brian Griffin.  12/18/05.
        do k = 2, gr%nnzp, 1

          if ( wp2(k) >= wtol*wtol ) then
            rtp2(k) 
     .      = max( rtp2(k), 
! Vince Larson commented out because may cause unstable feedback w/ wprtp eqn..
!       The correlation of w and rt may now exceed 1, which would be unphysical.  7 Jul 2007 
!     .             wprtp(k)*wprtp(k)/((1.0-Scm(k))*wp2(k)) + eps,
! End Vince Larson's commenting
     .             rttol*rttol )
            thlp2(k) 
     .      = max( thlp2(k), 
! Vince Larson commented out because may cause unstable feedback w/ wpthlp eqn.. 
!    The correlation of w and thl may now exceed 1, which would be unphysical.  7 Jul 2007 
!     .             wpthlp(k)*wpthlp(k)/((1.0-Scm(k))*wp2(k)) + eps,
! End Vince Larson's commenting
     .             thltol*thltol )
          else
            thlp2(k) = max( thlp2(k), 0.0 )
            rtp2(k)  = max( rtp2(k), 0.0 )
          end if

        end do ! k=2..gr%nnzp

        ! Clipping for up2/vp2
        ! This appears to be unneeded for now.  If these do need to be
        ! clipped in the future, this could be uncommented and budget
        ! could be added. -dschanen 24 April 2007
       where ( vp2 < 0.0 ) vp2 = 0.0
       where ( up2 < 0.0 ) up2 = 0.0

#ifdef STATS
        if ( lstats_samp .and. irtp2_cl > 0 ) then
          zm%x(:,irtp2_cl) = zm%x(:,irtp2_cl) + rtp2 / dt
          zm%n(:,irtp2_cl) = zm%n(:,irtp2_cl) + 1
        end if

        if ( lstats_samp .and. ithlp2_cl > 0 ) then
          zm%x(:,ithlp2_cl) = zm%x(:,ithlp2_cl) + thlp2 / dt
          zm%n(:,ithlp2_cl) = zm%n(:,ithlp2_cl) + 1
        end if

        if ( lstats_samp .and. iup2_cl > 0 ) then
          zm%x(:,iup2_cl) = zm%x(:,iup2_cl) + up2 / dt
          zm%n(:,iup2_cl) = zm%n(:,iup2_cl) + 1
        end if

        if ( lstats_samp .and. ivp2_cl > 0 ) then
          zm%x(:,ivp2_cl) = zm%x(:,ivp2_cl) + vp2 / dt
          zm%n(:,ivp2_cl) = zm%n(:,ivp2_cl) + 1
        end if
#endif

#ifdef STATS
        if ( lstats_samp ) then

          if ( irtp2_bt > 0 ) then
            zm%x(:,irtp2_bt) = zm%x(:,irtp2_bt) + rtp2 / dt
            zm%n(:,irtp2_bt) = zm%n(:,irtp2_bt) + 1
          end if

          if ( ithlp2_bt > 0 ) then
            zm%x(:,ithlp2_bt) = zm%x(:,ithlp2_bt) + thlp2 / dt
            zm%n(:,ithlp2_bt) = zm%n(:,ithlp2_bt) + 1
          end if

          if ( irtpthlp_bt > 0 ) then
            zm%x(:,irtpthlp_bt) = zm%x(:,irtpthlp_bt) + rtpthlp / dt
            zm%n(:,irtpthlp_bt) = zm%n(:,irtpthlp_bt) + 1
          end if

          if ( iup2_bt > 0 ) then
            zm%x(:,iup2_bt) = zm%x(:,iup2_bt) + up2 / dt
            zm%n(:,iup2_bt) = zm%n(:,iup2_bt) + 1
          end if

          if ( ivp2_bt > 0 ) then
            zm%x(:,ivp2_bt) = zm%x(:,ivp2_bt) + vp2 / dt
            zm%n(:,ivp2_bt) = zm%n(:,ivp2_bt) + 1
          end if

        end if
#endif /*STATS*/

        if ( scalar_calc ) then

        ! Implicit contributions to passive scalars

          call diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2, 
     .                       C2sclr_1d, nu2, beta, wtol_sqd, dt, liter,
     .                       lhs )


          ! Explicit contributions to passive scalars
          do i = 1, sclr_dim, 1
            call diag_var_rhs
     .         ( "sclrp2", a1, wp2, wp3,
     .           sclrm(:,i), sclrm(:,i), wpsclrp(:,i), wpsclrp(:,i), 
     .           sclrp2(:,i), dt, beta, wtol_sqd, liter, 
     .           sclr_rhs(:,i) )

          end do

          do i = 1, sclr_dim, 1
            call diag_var_rhs
     .           ( "sclrprtp", a1, wp2, wp3,
     .             sclrm(:,i), rtm, wpsclrp(:,i), wprtp, 
     .             sclrprtp(:,i), dt, beta, wtol_sqd, liter, 
     .             sclr_rhs(:,i+sclr_dim) )
          end do

          do i = 1, sclr_dim, 1
            call diag_var_rhs
     .           ( "sclrpthlp", a1, wp2, wp3,
     .             sclrm(:,i), thlm, wpsclrp(:,i), wpthlp, 
     .             sclrprtp(:,i), dt, beta, wtol_sqd, liter, 
     .             sclr_rhs(:,i+2*sclr_dim) )
          end do

          ! Solve the tridiagonal system

          call diag_var_solve
     .         ( "scalars", 3*sclr_dim, sclr_rhs, 
     .           lhs, sclr_solution, Valid_arr(6) )

          sclrp2(:,1:sclr_dim) = sclr_solution(:,1:sclr_dim)

          sclrprtp(:,1:sclr_dim) 
     .    = sclr_solution(:,sclr_dim+1:2*sclr_dim)

          sclrpthlp(:,1:sclr_dim) 
     .    = sclr_solution(:,2*sclr_dim+1:3*sclr_dim)

          ! Clip scalar variance terms
          do i =1, sclr_dim, 1
            do k = 2, gr%nnzp, 1
              if ( wp2(k) >= wtol*wtol ) then
                sclrp2(k,i) 
     .          = max
     .            ( sclrp2(k,i), 
! Vince Larson commented out because it may cause unstable feedback with wpsclrp eqn..
!     The correlation of w and sclr may now exceed 1, which would be unphysical.  7 Jul 2007
!     .              wpsclrp(k,i)*wpsclrp(k,i)/((1.0-Scm(k))*wp2(k))+eps,
! End Vince Larson's commenting
     .              sclrtol(i)*sclrtol(i) )
              else
                sclrp2(k,i) = max( sclrp2(k,i), 0.0 )
              end if ! wp2(k) >= wtol**2
            end do ! k
          end do ! i

        end if ! scalar_calc

        ! Check for singular matrices
        if ( any( .not. Valid_arr(:) ) ) then
          isValid = .false.
        end if

!       Error Reporting
!       Joshua Fasching February 2008
                
        if ( .not. isValid ) then
                
           write(fstderr,*) "Error in diag_var"
           
           write(fstderr,*) "Intent(in)"
           
           write(fstderr,*) "taum = ", taum
           write(fstderr,*) "wmm = ", wmm
           write(fstderr,*) "rtm = ", rtm
           write(fstderr,*) "wprtp = ", wprtp
           write(fstderr,*) "thlm = ", thlm
           write(fstderr,*) "wpthlp = ", wpthlp
           write(fstderr,*) "wpthvp = ", wpthvp
           write(fstderr,*) "um = ", um
           write(fstderr,*) "vm = ", vm
           write(fstderr,*) "wp2 = ", wp2
           write(fstderr,*) "wp3 = ", wp3
           write(fstderr,*) "upwp = ", upwp
           write(fstderr,*) "vpwp = ", vpwp
           write(fstderr,*) "Scm = ", Scm
           write(fstderr,*) "Skwm = ", Skwm
           write(fstderr,*) "Kht = ", Kht
           
           write(fstderr,*) "Intent(In/Out)"
           
           write(fstderr,*) "rtp2 = ", rtp2
           write(fstderr,*) "thlp2 = ", thlp2
           write(fstderr,*) "rtpthlp = ", rtpthlp
           write(fstderr,*) "up2 = ", up2
           write(fstderr,*) "vp2 = ", vp2
           
           if( present( sclrp2 ) ) then 
              write(fstderr,*) "sclrp2 = ", sclrp2
           endif
           
           if( present( sclrprtp ) ) then
             write(fstderr,*) "sclrprtp = ", sclrprtp
           endif
           
           if( present( sclrpthlp ) ) then
             write(fstderr,*) "sclrthlp = ", sclrpthlp
           endif
           
           write(fstderr,*) "Intent(out)"
           
           if( present( sclrm ) ) then
              write(fstderr,*) "sclrm = ", sclrm
           endif
           
           if( present( wpsclrp ) ) then
              write(fstderr,*) "wpsclrp = ", wpsclrp
           endif
           
        endif
        
        return
        
        end subroutine diag_var

!-----------------------------------------------------------------------
        subroutine diag_var_lhs( a1, wp2, wp3, taum, wmm, Kw2,
     .                           Cn, nu2, beta, eps, dt, liter,
     .                           lhs )
!       Description:
!       Compute LHS tridiagonal matrix for a variance or coveriance term

!       References:
!       None
!-----------------------------------------------------------------------
        use grid_class
        use diffusion, only: diffusion_mlev
#ifdef STATS
        use stats_hoc
#endif

        implicit none

        ! Constant parameters
        integer, parameter ::
     .  kp1diag = 1,
     .  kdiag   = 2,
     .  km1diag = 3

        ! Input Variables
        real, dimension(gr%nnzp), intent(in) ::
     .  a1,    ! See eqn. 20 in `Equations for HOC'     [-]
     .  wp2,   ! w'^2                                   [m^2/s^2]
     .  wp3,   ! w'^3                                   [m^3/s^3]
     .  taum,  ! Tau on moment. grid                    [s]
     .  wmm,   ! w wind on m.                           [m/s]
     .  Kw2,   ! Eddy diff. coef. on thermo. level      [m^2/s]
     .  Cn     ! Cn coefficient                         [-]

        real, intent(in) ::
     .  dt,    ! Timestep length                        [s]
     .  nu2,   ! Previously determined eddy viscosity.  [-]
     .  beta,  ! Constant parameter                     [-]
     .  eps    ! Small value to prevent a divide by zero[-]

        logical, intent(in) ::
     .  liter  ! Whether the variances are prognostic

        ! Output Variables
        real, dimension(3,gr%nnzp), intent(out) ::
     .  lhs ! Implicit contributions to the term

        ! Local Variables
        real, dimension(3) ::
     .  tmp

        ! Array indices
        integer :: k, kp1, km1

        ! Setup LHS of the tridiagonal system
        do k = 2, gr%nnzp-1, 1
          km1 = max( k-1, 1 )
          kp1 = min( k+1, gr%nnzp )

          ! Eddy Diffusion term (dp2)
          lhs(kp1diag:km1diag,k)
     .    = diffusion_mlev( Kw2(k), Kw2(kp1), nu2,
     .                      gr%dzt(kp1), gr%dzt(k), gr%dzm(k), k )

          lhs(kdiag,k)
     .    = lhs(kdiag,k) + term_dp1( Cn(k), taum(k) )  ! dp1

          if ( liter ) then
            lhs(kdiag,k) = lhs(kdiag,k) + ( 1.0 / dt ) ! Time tendency
          end if

          lhs(kp1diag:km1diag,k)
     .    = lhs(kp1diag:km1diag,k)
     .    + term_ma( wmm(k), gr%dzm(k), kp1, k ) ! ma

          lhs(kp1diag:km1diag,k)
     .    = lhs(kp1diag:km1diag,k)
     .    + term_ta_lhs
     .      ( zm2zt(a1,kp1), a1(k), zm2zt(a1,k), wp3(kp1), wp3(k), 
     .        zm2zt(wp2,kp1), zm2zt(wp2,k), gr%dzm(k), beta, eps, 
     .        kp1, k ) ! ta

#ifdef STATS
         if ( lstats_samp ) then

           if ( irtp2_dp1 + ithlp2_dp1 + irtpthlp_dp1  > 0 ) then
             tmp(1) = term_dp1( Cn(k), taum(k) )
             zmscr01(k) = -tmp(1)
           end if
         
           if ( irtp2_dp2 + ithlp2_dp2 + irtpthlp_dp2 + 
     .          iup2_dp2 + ivp2_dp2 > 0 ) then
             tmp(1:3)
     .       = diffusion_mlev( Kw2(k), Kw2(kp1), nu2,
     .                         gr%dzt(kp1), gr%dzt(k), gr%dzm(k), k )
             zmscr02(k) = -tmp(3)
             zmscr03(k) = -tmp(2)
             zmscr04(k) = -tmp(1)
           end if

           if ( irtp2_ta + ithlp2_ta + irtpthlp_ta +
     .          iup2_ta + ivp2_ta > 0 ) then
             tmp(1:3)
     .       = term_ta_lhs
     .         ( zm2zt(a1,kp1), a1(k), zm2zt(a1,k), wp3(kp1), wp3(k), 
     .           zm2zt(wp2,kp1), zm2zt(wp2,k), gr%dzm(k), beta, eps, 
     .           kp1, k )
             zmscr05(k) = -tmp(3)
             zmscr06(k) = -tmp(2)
             zmscr07(k) = -tmp(1)
           end if

           if ( irtp2_ma + ithlp2_ma + irtpthlp_ma +
     .          iup2_ma + ivp2_ma > 0 ) then
             tmp(1:3)
     .       = term_ma( wmm(k), gr%dzm(k), kp1, k )
             zmscr08(k) = -tmp(3)
             zmscr09(k) = -tmp(2)
             zmscr10(k) = -tmp(1)
           end if
         end if
#endif /*STATS*/

        end do ! k=2..gr%nnzp-1

        ! Boundary Conditions
        ! These are set so that the sfc_var value of rtp2, thlp2, or rtpthlp
        ! can be used at the lowest boundary and the values of those
        ! variables can be set to 0 at the top boundary.  Brian.  12/18/05.
        ! Fixed-point boundary conditions are used for both the variances and 
        ! the covariances.
        lhs(:,1) = 0.0
        lhs(:,gr%nnzp) = 0.0

        lhs(kdiag,1) = 1.0
        lhs(kdiag,gr%nnzp) = 1.0

        ! This boundary condition was changed by dschanen on 24 April 2007
        ! When we run prognostically we want to preserve the surface value.
!       if ( liter ) then
!         lhs(kdiag,1) = 1.0/dt
!         lhs(kdiag,1) = 1.0/dt
!       end if

        return
        end subroutine diag_var_lhs

!-----------------------------------------------------------------------
        subroutine diag_var_solve( solve_type, nrhs, rhs, 
     .                             lhs, xapxbp, isValid )

!-----------------------------------------------------------------------
        use lapack_wrap, only: tridag_solve, tridag_solvex!, band_solve
        use grid_class
#ifdef STATS
        use stats_hoc
#endif

        ! Constant parameters
        integer, parameter ::
     .  kp1diag = 1,
     .  kdiag   = 2,
     .  km1diag = 3

        ! Input variables
        integer, intent(in) :: nrhs  ! Number of right hand side vectors

        character(len=*), intent(in) :: 
     .  solve_type ! Variable(s) description

        ! Input/Ouput variables
        real, dimension(3,gr%nnzp), intent(inout) ::
     .  lhs  ! Implicit contributions to x variance/covariance term

        real, dimension(gr%nnzp,nrhs), intent(inout) ::
     .  rhs  ! Explicit contributions to x variance/covariance term

        ! Output variables
        real, dimension(gr%nnzp,nrhs), intent(inout) :: 
     .  xapxbp ! Computed value of the variable at <t+1> [units vary]

        logical, intent(out) ::
     .  isValid ! Returns as false in the event of a singular matrix

        ! Local variables
        real :: rcond  ! Est. of the reciprocal of the condition #

        ! Array indices
        integer :: k, kp1, km1

#ifdef STATS
        integer ::
     .  ixapxbp_dp1,
     .  ixapxbp_dp2,
     .  ixapxbp_ta,
     .  ixapxbp_ma,
     .  ixapxbp_pr1,
     .  ixapxbp_cn

        select case ( trim( solve_type ) )
        case ( "rtp2" )
          ixapxbp_cn  = irtp2_cn
          ixapxbp_dp1 = irtp2_dp1
          ixapxbp_dp2 = irtp2_dp2
          ixapxbp_ta  = irtp2_ta
          ixapxbp_ma  = irtp2_ma
          ixapxbp_pr1 = 0
        case ( "thlp2" )
          ixapxbp_cn  = ithlp2_cn
          ixapxbp_dp1 = ithlp2_dp1
          ixapxbp_dp2 = ithlp2_dp2
          ixapxbp_ta  = ithlp2_ta
          ixapxbp_ma  = ithlp2_ma
          ixapxbp_pr1 = 0
        case ( "rtpthlp" )
          ixapxbp_cn  = irtpthlp_cn
          ixapxbp_dp1 = irtpthlp_dp1
          ixapxbp_dp2 = irtpthlp_dp2
          ixapxbp_ta  = irtpthlp_ta
          ixapxbp_ma  = irtpthlp_ma
          ixapxbp_pr1 = 0
        case ( "up2" )
          ixapxbp_cn  = iup2_cn
          ixapxbp_dp1 = iup2_dp1
          ixapxbp_dp2 = iup2_dp2
          ixapxbp_ta  = iup2_ta
          ixapxbp_ma  = iup2_ma
          ixapxbp_pr1 = iup2_pr1
        case ( "vp2" )
          ixapxbp_cn  = ivp2_cn
          ixapxbp_dp1 = ivp2_dp1
          ixapxbp_dp2 = ivp2_dp2
          ixapxbp_ta  = ivp2_ta
          ixapxbp_ma  = ivp2_ma
          ixapxbp_pr1 = ivp2_pr1
        case default ! No budgets for passive scalars
          ixapxbp_cn  = 0
          ixapxbp_dp1 = 0
          ixapxbp_dp2 = 0
          ixapxbp_ta  = 0
          ixapxbp_ma  = 0
          ixapxbp_pr1 = 0
        end select
#endif

#ifdef STATS
        if ( lstats_samp .and. ixapxbp_cn > 0 ) then
          call tridag_solvex
     .         ( solve_type, gr%nnzp, nrhs, lhs(kp1diag,:), 
     .           lhs(kdiag,:), lhs(km1diag,:), rhs(:,1:nrhs), 
     .           xapxbp(:,1:nrhs), rcond, isValid )

          ! Est. of the condition number of the variance LHS matrix 
          sfc%x(1,ixapxbp_cn) = sfc%x(1,ixapxbp_cn) + 1.0 / rcond
          sfc%n(1,ixapxbp_cn) = sfc%n(1,ixapxbp_cn) + 1

        else 
          call tridag_solve
     .         ( solve_type, gr%nnzp, nrhs, lhs(kp1diag,:), 
     .           lhs(kdiag,:), lhs(km1diag,:), rhs(:,1:nrhs), 
     .           xapxbp(:,1:nrhs), isValid )
        end if
#else
        ! Solve system using tridag_solve. This uses LAPACK sgtsv,
        ! which relies on Gaussian elimination to decompose the matrix.
        call tridag_solve
     .       ( solve_type, gr%nnzp, nrhs, lhs(kp1diag,:), lhs(kdiag,:), 
     .         lhs(km1diag,:), rhs(:,1:nrhs), xapxbp(:,1:nrhs), 
     .         isValid )

        ! Alternative: Use LU decomposition instead.
!       call band_solve
!    .       ( solve_type, 1, 1, gr%nnzp, nrhs, 
!    .         lhs, rhs(:,1:nrhs), xapxbp(:,1:nrhs), isValid )
#endif

#ifdef STATS
        ! Compute implicit budget terms
        if ( lstats_samp ) then

          do k=2, gr%nnzp-1

            km1 = max( k-1, 1 )
            kp1 = min( k+1, gr%nnzp )

            if ( ixapxbp_dp1 > 0 ) then
              zm%x(k,ixapxbp_dp1) = zm%x(k,ixapxbp_dp1)
     .        + zmscr01(k) * xapxbp(k,1)
              zm%n(k,ixapxbp_dp1) = zm%n(k,ixapxbp_dp1) + 1
            end if
 
            if ( ixapxbp_dp2 > 0 ) then
              zm%x(k,ixapxbp_dp2) = zm%x(k,ixapxbp_dp2)
     .        + zmscr02(k) * xapxbp(km1,1)
     .        + zmscr03(k) * xapxbp(k,1)
     .        + zmscr04(k) * xapxbp(kp1,1)
              zm%n(k,ixapxbp_dp2) = zm%n(k,ixapxbp_dp2) + 1
            end if
 
            if ( ixapxbp_ta > 0 ) then
              zm%x(k,ixapxbp_ta) = zm%x(k,ixapxbp_ta)
     .        + zmscr05(k) * xapxbp(km1,1)
     .        + zmscr06(k) * xapxbp(k,1)
     .        + zmscr07(k) * xapxbp(kp1,1)
              zm%n(k,ixapxbp_ta) = zm%n(k,ixapxbp_ta) + 1
            end if

            if ( ixapxbp_ma > 0 ) then
              zm%x(k,ixapxbp_ma) = zm%x(k,ixapxbp_ma)
     .        + zmscr08(k) * xapxbp(km1,1)
     .        + zmscr09(k) * xapxbp(k,1)
     .        + zmscr10(k) * xapxbp(kp1,1)
              zm%n(k,ixapxbp_ma) = zm%n(k,ixapxbp_ma) + 1
            end if

            if ( ixapxbp_pr1 > 0 ) then
              zm%x(k,ixapxbp_pr1) = zm%x(k,ixapxbp_pr1)
     .        + zmscr11(k) * xapxbp(k,1)
              zm%n(k,ixapxbp_pr1) = zm%n(k,ixapxbp_pr1) + 1
            end if

          end do
        end if
#endif /*STATS*/

        return
        end subroutine diag_var_solve
!-----------------------------------------------------------------------
        subroutine diag_var_uv_rhs
     .             ( solve_type, a1, wp2, wp3, wpthvp, taum,
     .               xam, xbm, wpxap, wpxbp, xap2, xbp2,
     .               dt, C4, C5, C14, beta, T0, eps, liter, rhs )
!       Description:
!       Explicit contributions to v'^2 or u'^2
!-----------------------------------------------------------------------
        use grid_class
        use constants, only: grav
#ifdef STATS
        use stats_hoc
#endif

        implicit none

        ! Input Variables
        character(len=*), intent(in) :: solve_type

        real, dimension(gr%nnzp), intent(in) ::
     .  a1,     ! a1            [-]
     .  wp2,    ! w'^2          [m^2/s^2]
     .  wp3,    ! w'^3          [m^3/s^3]
     .  wpthvp, ! w'thv'        [m K/s]
     .  taum    ! Tau           [s]

        real, dimension(gr%nnzp), intent(in) ::
     .  xam,    ! x(1)          [m/s]
     .  xbm,    ! x(2)          [m/s]
     .  wpxap,  ! w'x'(1)       [m^2/s^2]
     .  wpxbp,  ! w'x'(2)       [m^2/s^2]
     .  xap2,   ! x'^2(1)       [m^2/s^2]
     .  xbp2    ! x'^2(2)       [m^2/s^2]

        real, intent(in) ::
     .  dt     ! Timestep      [s]

        real, intent(in) ::
     .  C4,    ! Model parameter                [-]
     .  C5,    ! Model parameter                [-]
     .  C14,   ! Model parameter                [-]
     .  T0,    ! Reference temperature          [K]
     .  beta,  ! Model parameter                [-]
     .  eps    ! Small value to prevent divz    [-]

        logical, intent(in) ::
     .  liter  ! Whether x is prognostic (T/F)

        real, dimension(gr%nnzp,1), intent(out) ::
     .  rhs    ! Explicit contributions to x variance/covariance terms

        ! Local Variables
        integer :: k, kp1, km1 ! Array indices

#ifdef STATS
        integer ::
     .  ixap2_ta,
     .  ixap2_tp,
     .  ixap2_dp1,
     .  ixap2_pr1,
     .  ixap2_pr2

        select case ( trim( solve_type ) )
        case ( "vp2" )
          ixap2_ta  = ivp2_ta
          ixap2_tp  = ivp2_tp
          ixap2_dp1 = ivp2_dp1
          ixap2_pr1 = ivp2_pr1
          ixap2_pr2 = ivp2_pr2
        case ( "up2" )
          ixap2_ta  = iup2_ta
          ixap2_tp  = iup2_tp
          ixap2_dp1 = iup2_dp1
          ixap2_pr1 = iup2_pr1
          ixap2_pr2 = iup2_pr2
        case default ! No budgets for passive scalars
          ixap2_ta  = 0
          ixap2_tp  = 0
          ixap2_dp1 = 0
          ixap2_pr1 = 0
          ixap2_pr2 = 0
        end select
#endif

        do k = 2, gr%nnzp-1, 1

          km1 = max( k-1, 1 )
          kp1 = min( k+1, gr%nnzp )

          rhs(k,1)
     .    = term_ta_rhs
     .      ( a1(kp1), a1(k), a1(km1), wp3(kp1), wp3(k),
     .        wp2(kp1), wp2(k), wp2(km1), 
     .        wpxap(kp1), wpxap(k), wpxap(km1),
     .        wpxap(kp1), wpxap(k), wpxap(km1),
     .        gr%dzm(k), beta, eps )
     .      + (1.0 - C5) 
     .          * term_tp( xam(kp1), xam(k), xam(kp1), xam(k),
     .                    wpxap(k), wpxap(k), gr%dzm(k) )
     .      + term_pr1( C4, C14, xbp2(k), wp2(k), taum(k) )
     .      + term_pr2
     .        ( C5, grav, T0, wpthvp(k), wpxap(k), wpxbp(k), 
     .          xam(kp1), xam(k), xbm(kp1), xbm(k), gr%dzm(k) ) 

          if ( liter ) then 
            rhs(k,1) = rhs(k,1) + 1.0/dt*xap2(k)  ! Time tendency
          end if
#ifdef STATS
        ! Compute implicit budget terms
          if ( lstats_samp ) then
            if ( ixap2_ta > 0 ) then
              zm%x(k,ixap2_ta) 
     .          = zm%x(k,ixap2_ta)
     .          + term_ta_rhs
     .            ( a1(kp1), a1(k), a1(km1), wp3(kp1), wp3(k),
     .              wp2(kp1), wp2(k), wp2(km1), 
     .              wpxbp(kp1), wpxbp(k), wpxbp(km1),
     .              wpxap(kp1), wpxap(k), wpxap(km1),
     .              gr%dzm(k), beta, eps )

            end if 

            if ( ixap2_dp1 > 0 ) then
              zmscr01(k) = - (1.0/3.0) * C14 / taum(k)
              zm%x(k,ixap2_dp1)
     .        = zm%x(k,ixap2_dp1) ! Explicit component
     .            - C14 * ( xbp2(k) + wp2(k) ) / ( 3.0 * taum(k) ) 
            end if

            if ( ixap2_pr1 > 0 ) then
              ! Note:
              ! The function term_pr1 is the explicit component of a
              ! semi-implicit solution to dp1 and pr1
              zm%x(k,ixap2_pr1)
     .        = zm%x(k,ixap2_pr1) ! Explicit component
     .        + ( C4 * (xbp2(k) + wp2(k)) ) / ( 3.0 * taum(k) )
              zmscr11(k) = - (2.0/3.0) * C4 / taum(k)
            end if

            if ( ixap2_pr2 > 0 ) then
              zm%x(k,ixap2_pr2)
     .        = zm%x(k,ixap2_pr2)
     .        + term_pr2
     .          ( C5, grav, T0, wpthvp(k), wpxap(k), wpxbp(k), 
     .            xam(kp1), xam(k), xbm(kp1), xbm(k), gr%dzm(k) ) 
              zm%n(k,ixap2_pr2) = zm%n(k,ixap2_pr2) + 1
            end if

            if ( ixap2_tp > 0 ) then
              zm%x(k,ixap2_tp) 
     .          = zm%x(k,ixap2_tp)
     .          + (1.0 - C5) 
     .             * term_tp( xam(kp1), xam(k), xam(kp1), xam(k),
     .                        wpxap(k), wpxap(k), gr%dzm(k) )
              zm%n(k,ixap2_tp) = zm%n(k,ixap2_tp) + 1
            end if

          end if ! lstats_samp
#endif /*STATS*/
        end do ! k=2..gr%nnzp-1

        ! Boundary Conditions
        ! These are set so that the sfc_var value of rtp2, thlp2, or rtpthlp
        ! can be used at the lowest boundary and the values of those
        ! variables can be set to 0 at the top boundary.  Brian.  12/18/05.
        ! Fixed-point boundary conditions are used for both the variances and 
        ! the covariances.

        ! This boundary condition was changed by dschanen on 24 April 2007
        ! When we run prognostically we want to preserve the surface value.
!       if ( liter ) then 
!         rhs(1,1) = xap2(1) + 1.0/dt*xap2(1)
!         rhs(gr%nnzp,1) = 1.0/dt*xap2(gr%nnzp)
!       else
        rhs(1,1) = xap2(1)
        rhs(gr%nnzp,1) = 0.0
!       end if

        return
        end subroutine diag_var_uv_rhs

!-----------------------------------------------------------------------
        subroutine diag_var_rhs( solve_type, a1, wp2, wp3,
     .                           xam, xbm, wpxap, wpxbp, xapxbp,
     .                           dt, beta, eps, liter, rhs )
!       Description:

!-----------------------------------------------------------------------
        use grid_class
#ifdef STATS
        use stats_hoc
#endif

        implicit none


        ! Input Variables
        character(len=*), intent(in) :: solve_type

        real, dimension(gr%nnzp), intent(in) ::
     .  a1,     ! a1            [-]
     .  wp2,    ! w'^2          [m^2/s^2]
     .  wp3     ! w'^3          [m^3/s^3]

        real, dimension(gr%nnzp), intent(in) ::
     .  wpxap,  ! w'x'(1)       [units vary]
     .  wpxbp,  ! w'x'(2)       [units vary]
     .  xam,    ! x(1)          [units vary]
     .  xbm,    ! x(2)          [units vary]
     .  xapxbp  ! x'(1) x'(2)   [units vary]

        real, intent(in) ::
     .  dt      ! Timestep      [s]

        real, intent(in) ::
     .  beta,  ! Model parameter                [-]
     .  eps    ! Small value to prevent divz    [-]

        logical, intent(in) ::
     .  liter   ! Whether x is prognostic (T/F)

        real, dimension(gr%nnzp,1), intent(out) ::
     .  rhs     ! Explicit contributions to x variance/covariance terms

        ! Local Variables
        integer :: k, kp1, km1 ! Array indices

#ifdef STATS
        integer ::
     .  ixapxbp_ta,
     .  ixapxbp_tp,
     .  ixapxbp_tp1,
     .  ixapxbp_tp2

        select case ( trim( solve_type ) )
        case ( "rtp2" )
          ixapxbp_ta  = irtp2_ta
          ixapxbp_tp  = irtp2_tp
          ixapxbp_tp1 = 0
          ixapxbp_tp2 = 0
        case ( "thlp2" )
          ixapxbp_ta  = ithlp2_ta
          ixapxbp_tp  = ithlp2_tp
          ixapxbp_tp1 = 0
          ixapxbp_tp2 = 0
        case ( "rtpthlp" )
          ixapxbp_ta  = irtpthlp_ta
          ixapxbp_tp  = 0
          ixapxbp_tp1 = irtpthlp_tp1
          ixapxbp_tp2 = irtpthlp_tp2
        case default ! No budgets for passive scalars
          ixapxbp_ta  = 0
          ixapxbp_tp  = 0
          ixapxbp_tp1 = 0
          ixapxbp_tp2 = 0
        end select
#endif
        do k = 2, gr%nnzp-1, 1

          km1 = max( k-1, 1 )
          kp1 = min( k+1, gr%nnzp )

          rhs(k,1)
     .    = term_ta_rhs
     .      ( a1(kp1), a1(k), a1(km1), wp3(kp1), wp3(k),
     .        wp2(kp1), wp2(k), wp2(km1), 
     .        wpxbp(kp1), wpxbp(k), wpxbp(km1),
     .        wpxap(kp1), wpxap(k), wpxap(km1),
     .        gr%dzm(k), beta, eps )
     .      + term_tp( xam(kp1), xam(k), xbm(kp1), xbm(k), 
     .                 wpxbp(k), wpxap(k), gr%dzm(k) )

          if ( liter ) then 
            rhs(k,1) = rhs(k,1) + 1.0/dt*xapxbp(k)  ! Time tendency
          end if

        end do ! k=2..gr%nnzp-1

        ! Boundary Conditions
        ! These are set so that the sfc_var value of rtp2, thlp2, or rtpthlp
        ! can be used at the lowest boundary and the values of those
        ! variables can be set to 0 at the top boundary.  Brian.  12/18/05.
        ! Fixed-point boundary conditions are used for both the variances and 
        ! the covariances.

        ! This boundary condition was changed by dschanen on 24 April 2007
        ! When we run prognostically we want to preserve the surface value.
!       if ( .false. ) then
!         rhs(1,1) = xapxbp(1) + 1.0/dt*xapxbp(1)
!         rhs(gr%nnzp,1) = 1.0/dt*xapxbp(gr%nnzp)
!       else
        rhs(1,1) = xapxbp(1)
        rhs(gr%nnzp,1) = 0.0
!       end if

#ifdef STATS
        ! Compute implicit budget terms
        if ( lstats_samp ) then

          do k=1, gr%nnzp

            km1 = max( k-1, 1 )
            kp1 = min( k+1, gr%nnzp )
            if ( ixapxbp_ta > 0 ) then
              zm%x(k,ixapxbp_ta) 
     .          = zm%x(k,ixapxbp_ta)
     .          + term_ta_rhs
     .           ( a1(kp1), a1(k), a1(km1), wp3(kp1), wp3(k),
     .             wp2(kp1), wp2(k), wp2(km1), 
     .             wpxbp(kp1), wpxbp(k), wpxbp(km1),
     .             wpxap(kp1), wpxap(k), wpxap(km1),
     .             gr%dzm(k), beta, eps )

            end if 
            ! rtp2/thlp2 case (1 term)
            if ( ixapxbp_tp > 0 ) then
              zm%x(k,ixapxbp_tp) 
     .          = zm%x(k,ixapxbp_tp)
     .          + term_tp( xam(kp1), xam(k), xbm(kp1), xbm(k), 
     .                     wpxbp(k), wpxap(k), gr%dzm(k) )
              zm%n(k,ixapxbp_tp) = zm%n(k,ixapxbp_tp) + 1
            end if

            ! rtpthlp case (2 terms)
            if ( ixapxbp_tp1 > 0 ) then
              zm%x(k,ixapxbp_tp1) = zm%x(k,ixapxbp_tp1)
     .        - wpxap(k) * gr%dzm(k) * ( xbm(kp1) - xbm(k) )
              zm%n(k,ixapxbp_tp1) = zm%n(k,ixapxbp_tp1) + 1
            end if

            if ( ixapxbp_tp2 > 0 ) then
              zm%x(k,ixapxbp_tp2) = zm%x(k,ixapxbp_tp2)
     .        - wpxbp(k) * gr%dzm(k) * ( xam(kp1) - xam(k) )
              zm%n(k,ixapxbp_tp2) = zm%n(k,ixapxbp_tp2) + 1
            end if

          end do
        end if
#endif /*STATS*/

        return
        end subroutine diag_var_rhs

!-----------------------------------------------------------------------
        pure function term_ta_lhs( a1_tkp1, a1, a1_tk, wp3p1, wp3, 
     .                             wp2_tkp1, wp2_tk, dzm, beta, eps, 
     .                             tkp1, tk )
     .  result( lhs )

!       Description:
!       Turbulent advection term (implicit contributions)

!       References:
!-----------------------------------------------------------------------
        use grid_class

        implicit none

        ! External
        intrinsic :: max

        ! Constant parameters
        integer, parameter ::
     .  kp1diag = 1,
     .  kdiag   = 2,
     .  km1diag = 3

        ! Input variables
        real, intent(in) ::
     .  a1_tkp1,  ! a1 interpolated to t-lev(k+1)   [-]
     .  a1,       ! a1(k)                           [-]
     .  a1_tk,    ! a1 interpolated to t-lev(k)     [-]
     .  wp3p1,    ! w'^3(k+1)                       [m^3/s^3]
     .  wp3,      ! w'^3(k)                         [m^3/s^3]
     .  wp2_tkp1, ! w'^2 interpolated to t-lev(k+1) [m^2/s^2]
     .  wp2_tk,   ! w'^2 interpolated to t-lev(k)   [m^2/s^2]
     .  dzm,      ! Inverse of the grid spacing     [m]
     .  beta,     ! Model parameter                 [-]
     .  eps       ! Model parameter                 [-]

        integer, intent(in) ::
     .  tkp1,  ! Thermodynamic level k+1 index.
     .  tk     ! Thermodynamic level k index.

        ! Return Variable
        real, dimension(3) :: lhs

        ! Brian tried a new discretization for the turbulent advection term, 
        ! which contains the term 
        ! -d[ a1 * (1/3)*beta * (wp3/wp2) * xapxbp ] / dz.  In order to help 
        ! stabilize xapxbp, a1 has been pulled outside the derivative.

        lhs(kp1diag) 
!     .  = + (1.0/3.0) * beta * dzm
!     .      * a1_tkp1 * ( wp3p1 / max( wp2_tkp1, eps ) ) 
!     .      * gr%weights_zm2zt(tkp1,1)
     .  = + (1.0/3.0) * beta * a1 * dzm
     .      * ( wp3p1 / max( wp2_tkp1, eps ) ) 
     .      * gr%weights_zm2zt(tkp1,1)

        lhs(kdiag) 
!     .  = + (1.0/3.0) * beta * dzm
!     .      * (   a1_tkp1 * ( wp3p1 / max( wp2_tkp1, eps ) ) 
!     .            * gr%weights_zm2zt(tkp1,2)
!     .          - a1_tk * ( wp3 / max( wp2_tk, eps ) )
!     .            * gr%weights_zm2zt(tk,1)
!     .        )
     .  = + (1.0/3.0) * beta * a1 * dzm
     .      * (   ( wp3p1 / max( wp2_tkp1, eps ) ) 
     .            * gr%weights_zm2zt(tkp1,2)
     .          - ( wp3 / max( wp2_tk, eps ) )
     .            * gr%weights_zm2zt(tk,1)
     .        )

        lhs(km1diag) 
!     .  = - (1.0/3.0) * beta * dzm
!     .      * a1_tk * ( wp3 / max( wp2_tk, eps ) )
!     .      * gr%weights_zm2zt(tk,2)
     .  = - (1.0/3.0) * beta * a1 * dzm
     .      * ( wp3 / max( wp2_tk, eps ) )
     .      * gr%weights_zm2zt(tk,2)

        ! End of Brian's a1 change.  14 Feb 2008.

        return
        end function term_ta_lhs

!-----------------------------------------------------------------------
        pure function term_ta_rhs( a1p1, a1, a1m1, wp3p1, wp3,
     .                             wp2p1, wp2, wp2m1,
     .                             wpxbpp1, wpxbp, wpxbpm1, 
     .                             wpxapp1, wpxap, wpxapm1,
     .                             dzm, beta, eps )
     .  result( rhs )

!       Description:
!       Turbulent advection term (explicit contributions)

!       References:
!-----------------------------------------------------------------------
        implicit none

        ! External
        intrinsic :: max

        ! Input variables
        real, intent(in) ::
     .  a1p1,   ! a1(k+1)                       [-]
     .  a1,     ! a(k)                          [-]
     .  a1m1,   ! a1(k-1)                       [-]
     .  wp3p1,  ! w'^3(k+1)                     [m^3/s^3]
     .  wp3,    ! w'^3(k)                       [m^3/s^3]
     .  wp2p1,  ! w'^2(k+1)                     [m^2/s^2]
     .  wp2,    ! w'^2(k)                       [m^2/s^2]
     .  wp2m1,  ! w'^2(k+1)                     [m^2/s^2]
     .  wpxbpp1,! w'x'(k+1)                     [m/s units]
     .  wpxbp,  ! w'x'(k)                       [m/s units]
     .  wpxbpm1,! w'x'(k-1)                     [m/s units]
     .  wpxapp1,! w'x'(k+1)                     [m/s units]
     .  wpxap,  ! w'x'(k)                       [m/s units]
     .  wpxapm1,! w'x'(k-1)                     [m/s units]
     .  dzm,    ! Inverse of the grid spacing   [m]
     .  beta,   ! Model parameter               [-]
     .  eps     ! Model parameter               [-]

        ! Return Variable
        real :: rhs

        ! Brian tried a new discretization for the turbulent advection term, 
        ! which contains the term
        ! -d[ a1^2 * (1-(1/3)*beta) * (wp3/wp2^2) * wpxap * wpxbp ] / dz.  
        ! In order to help stabilize xapxbp, a1^2 has been pulled outside 
        ! the derivative.

        rhs
!     .  = - ( 1.0 - (1.0/3.0) * beta ) * (1.0/4.0) * dzm
!     .      * (  ( a1p1 + a1 )**2 * ( wpxapp1 + wpxap ) 
!     .            * ( wpxbpp1 + wpxbp ) * wp3p1 
!     .              / ( max( wp2p1 + wp2, 2.0*eps ) )**2
!     .          - ( a1 + a1m1 )**2 * ( wpxap + wpxapm1 ) 
!     .            * ( wpxbp + wpxbpm1 ) * wp3
!     .              / ( max( wp2 + wp2m1, 2.0*eps ) )**2
!     .         )
     .  = - (a1**2) * ( 1.0 - (1.0/3.0) * beta ) * dzm
     .      * (   ( wpxapp1 + wpxap ) * ( wpxbpp1 + wpxbp ) 
     .             * wp3p1 / ( max( wp2p1 + wp2, 2.0*eps ) )**2
     .          - ( wpxap + wpxapm1 ) * ( wpxbp + wpxbpm1 ) 
     .             * wp3 / ( max( wp2 + wp2m1, 2.0*eps ) )**2
     .         )

        ! End of Brian's a1 change.  14 Feb 2008.

        return
        end function term_ta_rhs

!-----------------------------------------------------------------------
        pure function term_tp( xamp1, xam, xbmp1, xbm, 
     .                         wpxbp, wpxap, dzm )
     .  result( rhs )

!       Description:
!       Turbulent production

!       References:
!-----------------------------------------------------------------------

        implicit none

        ! Input variables
        real, intent(in) ::
     .  xam,  ! x       <k>                     [units vary]
     .  xamp1,! x       <k+1>                   [units vary]
     .  xbm,  ! x       <k>                     [units vary]
     .  xbmp1,! x       <k+1>                   [units vary]
     .  wpxbp,! w'x'    <k>                     [m/s units]
     .  wpxap,! w'x'    <k>                     [m/s units]
     .  dzm   ! Inverse of the grid spacing <k> [m]

        ! Return Variable
        real :: rhs

        rhs
     .  = - wpxbp * dzm * ( xamp1 - xam )
     .    - wpxap * dzm * ( xbmp1 - xbm )

        return
        end function term_tp

!-----------------------------------------------------------------------
        pure function term_ma( wmm, dzm, tkp1, tk ) 
     .  result( lhs )

!       Description:
!       Mean advection term

!       References:
!-----------------------------------------------------------------------
        use grid_class

        implicit none

        ! Constant parameters
        integer, parameter ::
     .  kp1diag = 1,
     .  kdiag   = 2,
     .  km1diag = 3

        real, intent(in) ::
     .  wmm, ! w wind on m                      [m/s]
     .  dzm  ! Inverse of the grid spacing      [m]

        integer, intent(in) ::
     .  tkp1,  ! Thermodynamic level k+1 index.
     .  tk     ! Thermodynamic level k index.

        ! Return Variable
        real, dimension(3) :: lhs

        lhs(kp1diag) = + wmm * dzm * gr%weights_zm2zt(tkp1,1)
        lhs(kdiag)   = + wmm * dzm * (  gr%weights_zm2zt(tkp1,2) 
     .                                - gr%weights_zm2zt(tk,1)  )
        lhs(km1diag) = - wmm * dzm * gr%weights_zm2zt(tk,2)

        return
        end function term_ma

!-----------------------------------------------------------------------
        pure function term_dp2( nu2, dzm, dzt, dztp1 ) 
     .  result( lhs )

!       Description:
!       Dissipation term

!       References:
!-----------------------------------------------------------------------
        implicit none

        ! Constant parameters
        integer, parameter ::
     .  kp1diag = 1,
     .  kdiag   = 2,
     .  km1diag = 3

        real, intent(in) ::
     .  nu2,  ! Previously determined eddy viscosity     [m^2/s]
     .  dzt,  ! Inverse of the grid spacing on t <k>     [m]
     .  dztp1,! Inverse of the grid spacing on t <k+1>   [m]
     .  dzm   ! Inverse of the grid spacing on m <k>     [m]

        ! Return Variable
        real, dimension(3) :: lhs

        lhs(kp1diag) = - nu2 * dzm * dzt
        lhs(kdiag)   = + nu2 * dzm * ( dztp1 + dzt )
        lhs(km1diag) = - nu2 * dzm * dztp1

        return
        end function term_dp2

!-----------------------------------------------------------------------
        pure function term_dp1( Cn, taum ) 
     .  result( lhs )

!       Description:
!       Dissipation term

!       References:
!-----------------------------------------------------------------------
        implicit none

        ! Constant parameters
!       integer, parameter ::
!    .  kdiag = 1

        real, intent(in) ::
     .  Cn,  ! Coefficient      [-]
     .  taum ! Tau              [s]

!       real, dimension(1) :: lhs
        real :: lhs

!       lhs(kdiag) = + C2 / taum
        lhs = + Cn / taum

        return
        end function term_dp1

!-----------------------------------------------------------------------
        pure function term_pr1( C4, C14, xbp2, wp2, taum )
     .  result( rhs )

!       Description:

!       References:
!-----------------------------------------------------------------------

        implicit none

        real, intent(in) ::
     .  C4,     ! C4 coefficient        [-]
     .  C14,    ! C14 coefficient       [-]
     .  xbp2,   ! v'^2 or u'^2 <k>      [m^2/s^2]
     .  wp2,    ! w'^2 <k>              [m^2/s^2]
     .  taum    ! Tau on m <k>          [s]

        real :: rhs

        rhs = + 1.0/3.0 * ( C4 - C14 ) * ( xbp2 + wp2 ) / taum

        return
        end function term_pr1

!-----------------------------------------------------------------------
        pure function term_pr2( C5, grav, T0, wpthvp, upwp, vpwp, 
     .                          ump1, um, vmp1, vm, dzm ) 
     .  result( rhs )

!       Description:

!       References:
!-----------------------------------------------------------------------
        implicit none

        real, intent(in) ::
     .  C5,    ! C5 Coefficient                 [-]
     .  grav,  ! Gravitational acceleration     [m/s^2]
     .  T0,    ! Reference temperature          [K]
     .  wpthvp,! w'thv' <k>                     [m/K/s]
     .  upwp,  ! u'w' <k>                       [m^2/s^2]
     .  vpwp,  ! v'w' <k>                       [m^2/s^2]
     .  ump1,  ! u <k+1>                        [m/s]
     .  um,    ! u <k>                          [m/s]
     .  vmp1,  ! v <k+1>                        [m/s]
     .  vm,    ! v <k>                          [m/s]
     .  dzm    ! Inverse of the grid spacing <k>[m]

        real :: rhs

        ! As applied to w'2
        rhs = + (2.0/3.0) * C5
     .          * ( ( grav / T0 ) * wpthvp
     .              -upwp * dzm * ( ump1 - um )
     .              -vpwp * dzm * ( vmp1 - vm ) )


        return
        end function term_pr2

        end module diagnose_variances
