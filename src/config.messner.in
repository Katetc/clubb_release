# $Id: config.messner.in,v 1.15 2006-11-26 22:03:57 dschanen Exp $
# Configuration file for Messner node

# == Paths ==
# This is where the make command is going to put the resulting files
PREFIX = ..
BINDIR = $(PREFIX)/bin
LIBDIR = $(PREFIX)/lib

# == Compiler invocation ==
FC = g95 #	G95
#FC = ifort #	Intel Fortran 9
#FC = pgf90 #	Portland Group Fortran 90 5.x/6.x

# == Debugging ==
# It is sometimes helpful to turn on floating-point trapping for the 
#  standalone program, but this will not work when using the tuner.
# In PGF: -Ktrap=inv,unf
# In g95: `setenv G95_FPU_INVALID TRUE' or `export G95_FPU_INVALID=TRUE'
# In ifort: -fpe=0
# The usual options:
DEBUG = -g -fbounds-check -mieee-fp -ftrace=full #	g95
#DEBUG = -fpe=0 -g -check bounds -mieee-fp #	ifort
#DEBUG = -g -C -Kieee #			pgf90

# == Machine specific flags ==
# Note: When building hoc as a shared library add -fPIC below
ARCH = -march=pentium4 -msse2 -mfpmath=sse # g95, P4
#ARCH = -arch pn4 -xP # ifort, P4
#ARCH = -tp p7 # pgf90, P4

# == Optimization ==
# These are all pretty conservative options. Check your compiler manual
# for information on using more aggressive techniques (inlining, etc.)
OPTIMIZE = -O2

# == NetCDF Location ==
NC_LOC = /usr/local/netcdf-g95
#NC_LOC = /usr/local/netcdf-intel
#NC_LOC = /usr/local/netcdf-pgi
 
# == LAPACK libraries ==
LAPACK = -llapack -lf77blas -lcblas -latlas -L/lib/ssa -lg2c # ATLAS BLAS/LAPACK
#LAPACK = -L/opt/intel/mkl/8.1/lib/32 -lmkl_lapack32 -lmkl_p4p -lmkl -lmkl_vml_p4p -lvml -lguide -lpthread # Intel MKL (P4)
#LAPACK = -llapack -lblas -L/lib/ssa -lg2c # Generic with reference BLAS

# == Linking Flags ==
# Use -s to strip (no debugging); 
# Use -L<library path> -l<lib> to link in an external library
# Use -Wl,-rpath <library path> to set a search path for shared libs
LDFLAGS = -L$(LIBDIR) -Wl,-rpath,$(LIBDIR) -lhoc_param -lhoc_bugsrad -L$(NC_LOC)/lib -lnetcdf $(LAPACK)

# == Compiler flags (all) ==
# Preprocessing Directives:
#   -DSTATS enables statistics
#   -DSCALARS enables passive scalars
#   -DBIG_ENDIAN_IO use only if compiler performs big endian file i/O
#                   regardless of internal representation
#   -DLITTLE_ENDIAN_IO use only if compiler performs little endian file i/O
#                   regardless of internal representation
#   -Dradoffline and -Dnooverlap (see bugsrad documentation)
# You will need to `make clean' if you change these
# Use -I<include path> to set a module or header file directory

FCFLAGS = $(DEBUG) $(ARCH) -DSTATS -Dnooverlap -Dradoffline -I$(NC_LOC)/include
#FCFLAGS = $(OPTIMIZE) $(ARCH) -DSTATS -Dnooverlap -Dradoffline -I$(NC_LOC)/include
#FCFLAGS = $(OPTIMIZE) $(ARCH) -DSTATS -DSCALARS -Dnooverlap -Dradoffline -I$(NC_LOC)/include 

# == Static library processing ==
AR = ar
ARFLAGS = cru
RANLIB = ranlib

# == Shared library processing ==
SHARED = $(FC)
SHAREDFLAGS = -fPIC -shared
