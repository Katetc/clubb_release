!$Id$
module generate_lh_sample_module

  implicit none

  public :: generate_lh_sample, generate_uniform_sample, &
     ltqnorm, multiply_Cholesky

  private :: sample_points, gaus_mixt_points, & 
    truncate_gaus_mixt, &
    st_2_rtthl, log_sqd_normalized, choose_permuted_random, &
    set_min_varnce_and_mean, construct_gaus_LN_element, &
    construct_LN_LN_element, corr_LN_to_cov_gaus, &
    corr_gaus_LN_to_cov_gaus, mu_LN_to_mu_gaus, &
    sigma_LN_to_sigma_gaus

  logical, public :: &
    l_fixed_corr_initialized = .false.

  double precision, allocatable, dimension(:,:), target, private :: &
    corr_stw_cloud_Cholesky, & ! Cholesky factorization of the correlation matrix
    corr_stw_below_Cholesky    ! Cholesky factorization of the correlation matrix

  double precision, allocatable, dimension(:), private :: &
    corr_stw_cloud_scaling, & ! Scaling factors for the correlation matrix [-]
    corr_stw_below_scaling    ! Scaling factors for the correlation matrix [-]

  logical, private :: &
    l_corr_stw_cloud_scaling, & ! Whether we're scaling the correlation matrix
    l_corr_stw_below_scaling

  private ! Default scope

  contains

!-------------------------------------------------------------------------------
  subroutine generate_lh_sample &
             ( n_micro_calls, d_variables, hydromet_dim, & 
               wm, rcm, rvm, thlm, & 
               mixt_frac, rrtthl, &
               w1_in, w2_in, varnce_w1_in, varnce_w2_in, &
               thl1_in, thl2_in, varnce_thl1_in, varnce_thl2_in, &
               rt1_in, rt2_in, varnce_rt1_in, varnce_rt2_in, &
               s1_in, s2_in, stdev_s1_in, stdev_s2_in, &
               crt1, crt2, cthl1, cthl2, &
               hydromet, xp2_on_xm2_array_cloud, xp2_on_xm2_array_below, &
               corr_array_cloud, corr_array_below, &
               X_u_one_lev, X_mixt_comp_one_lev, &
               LH_rt, LH_thl, X_nl_one_lev )
! Description:
!   This subroutine generates a Latin Hypercube sample.

! References:
!   ``Supplying Local Microphysical Parameterizations with Information about
!     Subgrid Variability: Latin Hypercube Sampling'', JAS Vol. 62,
!     p. 4010--4026, Larson, et al. 2005.
!-------------------------------------------------------------------------------

    use constants_clubb, only:  &
      max_mag_correlation, &  ! Constant
      s_mellor_tol,  &  ! s tolerance in kg/kg
      rt_tol, &         ! rt tolerance in kg/kg
      thl_tol, &        ! thetal tolerance in K
      w_tol_sqd, &      ! w^2 tolerance in m^2/s^2
      rc_tol, &         ! rc tolerance in kg/kg
      rr_tol, &         ! rr tolerance in kg/kg
      Nr_tol, &         ! Nr tolerance in #/kg
      Nc_tol            ! Nc tolerance in #/kg

    use array_index, only: &
      iiNcm,    & ! Variables
      iiNim,    &
      iiNsnowm, &
      iiNrm,    &
      iirrainm, &
      iiricem, &
      iirsnowm, &
      iiNgraupelm, &
      iirgraupelm

    use latin_hypercube_arrays, only: &
      iiLH_rrain, &
      iiLH_rsnow, &
      iiLH_rice, &
      iiLH_rgraupel, &
      iiLH_Nr, &
      iiLH_Nc, &
      iiLH_Ni, &
      iiLH_Nsnow, &
      iiLH_Ngraupel, &
      iiLH_s_mellor, &
      iiLH_t_mellor, &
      iiLH_w

    use mt95, only: genrand_real ! Constants

    use matrix_operations, only: &
      set_lower_triangular_matrix_dp, & ! Procedures
      get_lower_triangular_matrix_sp, &
      row_mult_lower_tri_matrix, &
      print_lower_triangular_matrix

    use matrix_operations, only: Cholesky_factor ! Procedure(s)

    use matrix_operations, only: &
      symm_covar_matrix_2_corr_matrix ! Procedure(s)

    use error_code, only:  &
      clubb_at_least_debug_level  ! Procedure(s)

    use constants_clubb, only:  &
      fstderr  ! Constant(s)

    use parameters_microphys, only: &
      l_fix_s_t_correlations ! Varible(s)

    implicit none

    ! External
    intrinsic :: dble, min, max, sqrt, null

    ! Input Variables
    integer, intent(in) :: &
      n_micro_calls, & ! `n' Number of calls to microphysics (normally=2)
      d_variables,   & ! `d' Number of variates (normally 3 + microphysics specific variables)
      hydromet_dim     ! Number of hydrometeor species

    real, dimension(hydromet_dim), intent(in) :: &
      hydromet ! Hydrometeor species [units vary]

    real, intent(in) :: &
      wm,         & ! Vertical velocity                   [m/s]
      rcm,        & ! Mean liquid water mixing ratio      [kg/kg]
      rvm,        & ! Mean vapor water mixing ratio       [kg/kg]
      thlm          ! Mean liquid potential temperature   [K]

    real, intent(in) :: &
      mixt_frac,      & ! Mixture fraction					[-]
      rrtthl,         & ! Sub-plume correlation coefficient between rt, thl 
      !			  varies between -1 < rrtthl < 1			[-]
      w1_in,          & ! Mean of w for 1st normal distribution                 [m/s]
      w2_in,          & ! Mean of w for 2nd normal distribution                 [m/s]
      varnce_w1_in,   & ! Variance of w for 1st normal distribution         [m^2/s^2]
      varnce_w2_in,   & ! Variance of w for 2nd normal distribution         [m^2/s^2]
      thl1_in,        & ! Mean of th_l for 1st normal distribution                [K]
      thl2_in,        & ! Mean of th_l for 2nd normal distribution                [K]
      varnce_thl1_in, & ! Variance of th_l for 1st normal distribution          [K^2]
      varnce_thl2_in, & ! Variance of th_l for 2nd normal distribution          [K^2]
      rt1_in,         & ! Mean of r_t for 1st normal distribution             [kg/kg]
      rt2_in,         & ! Mean of r_t for 2nd normal distribution             [kg/kg]
      varnce_rt1_in,  & ! Variance of r_t for 1st normal distribution     [kg^2/kg^2]
      varnce_rt2_in,  & ! Variance of r_t for 2nd normal distribution     [kg^2/kg^2]
      s1_in,          & ! Mean of s for 1st normal distribution               [kg/kg]
      s2_in,          & ! Mean of s for 2nd normal distribution               [kg/kg]
      stdev_s1_in,    & ! Standard deviation of s for 1st normal distribution [kg/kg]
      stdev_s2_in,    & ! Standard deviation of s for 2nd normal distribution [kg/kg]
      crt1,           & ! Coefficient for s'                                      [-]
      crt2,           & ! Coefficient for s'                                      [-]
      cthl1,          & ! Coefficient for s'                                    [1/K]
      cthl2             ! Coefficient for s'                                    [1/K]

    ! From the KK_microphys_module
    real, dimension(d_variables), target, intent(in) :: &
      xp2_on_xm2_array_cloud, & ! Variance over mean for sampled variables    [-]
      xp2_on_xm2_array_below

    real, dimension(d_variables,d_variables), target, intent(in) :: &
      corr_array_cloud, & ! Correlations for sampled variables    [-]
      corr_array_below

    real(kind=genrand_real), intent(in), dimension(n_micro_calls,d_variables+1) :: &
      X_u_one_lev ! Sample drawn from uniform distribution from a particular grid level

    integer, intent(in), dimension(n_micro_calls) :: &
      X_mixt_comp_one_lev ! Whether we're in the 1st or 2nd mixture component

    ! Output Variables
    real, intent(out), dimension(n_micro_calls) :: &
      LH_rt, & ! Total water mixing ratio          [kg/kg]
      LH_thl   ! Liquid potential temperature      [K]

    double precision, intent(out), dimension(n_micro_calls,d_variables) :: &
      X_nl_one_lev ! Sample that is transformed ultimately to normal-lognormal

    ! Local Variables

    logical, dimension(d_variables) :: &
      l_d_variable_lognormal ! Whether a given variable in X_nl has a lognormal dist.

    real :: &
      rtm,         & ! Mean total water mixing ratio                       [kg/kg]
      s_mellor,    & ! Mean s_mellor (for when stdev_s1 < s_mellor_tol)    [kg/kg]
      w1,          & ! Mean of w for 1st normal distribution                 [m/s]
      w2,          & ! Mean of w for 2nd normal distribution                 [m/s]
      varnce_w1,   & ! Variance of w for 1st normal distribution         [m^2/s^2]
      varnce_w2,   & ! Variance of w for 2nd normal distribution         [m^2/s^2]
      thl1,        & ! Mean of th_l for 1st normal distribution                [K]
      thl2,        & ! Mean of th_l for 2nd normal distribution                [K]
      varnce_thl1, & ! Variance of th_l for 1st normal distribution          [K^2]
      varnce_thl2, & ! Variance of th_l for 2nd normal distribution          [K^2]
      rt1,         & ! Mean of r_t for 1st normal distribution             [kg/kg]
      rt2,         & ! Mean of r_t for 2nd normal distribution             [kg/kg]
      varnce_rt1,  & ! Variance of r_t for 1st normal distribution     [kg^2/kg^2]
      varnce_rt2,  & ! Variance of r_t for 2nd normal distribution     [kg^2/kg^2]
      s1,          & ! Mean of s for 1st normal distribution               [kg/kg]
      s2,          & ! Mean of s for 2nd normal distribution               [kg/kg]
      stdev_s1,    & ! Standard deviation of s for 1st normal distribution [kg/kg]
      stdev_s2       ! Standard deviation of s for 2nd normal distribution [kg/kg]

    double precision :: &
      stdev_t1, &  ! Standard deviation of t for the 1st normal distribution [kg/kg]
      stdev_t2     ! Standard deviation of t for the 1st normal distribution [kg/kg]

    double precision :: &
      cloud_frac1, & ! Cloud fraction for 1st normal distribution              [-]
      cloud_frac2    ! Cloud fraction for 2nd normal distribution              [-]


    ! Use to clip the magnitude of the correlation between rt and thl
    real :: rrtthl_reduced ! Correlation between rt and thl [-]

    double precision :: &
      rrtthl_covar_reduced1, & ! Covariance of rtthl for plume 1 [K^2/kg^2]
      rrtthl_covar_reduced2    ! Covariance of rtthl for plume 2 [K^2/kg^2]

    ! Means of s, t, w, & hydrometeors for plumes 1 and 2
    real, dimension(d_variables) :: &
      mu1, mu2

    ! Columns of Sigma_stw, X_nl_one_lev:  1   2   3   4 ... d_variables
    !                                      s   t   w   hydrometeors
    double precision, dimension(d_variables,d_variables) :: &
      Sigma_stw_1, & ! Covariance of s,t, w + hydrometeors for plume 1
      Sigma_stw_2    ! Covariance of s,t, w + hydrometeors for plume 2

    double precision :: &
!     Ncm,     & ! Cloud droplet number concentration.[number / kg air]
      var_Nc1, & ! PDF param for width of plume 1.    [(#/kg)^2]
      var_Nc2, & ! PDF param for width of plume 2.    [(#/kg^2]
      Nrm,     & ! Rain droplet number concentration. [number / kg air]
      var_Nr1, & ! PDF param for width of plume 1.    [(#/kg)^2]
      var_Nr2    ! PDF param for width of plume 2.    [(#/kg^2]

    real :: corr_rrNr, covar_rrNr1, covar_rrNr2, corr_srr, corr_sNr, &
            covar_sNr1, covar_sNr2, covar_srr1, covar_srr2

    double precision :: covar_trr1, covar_trr2, covar_tNr2, covar_tNr1

!   real :: &
!     stdev_Nc, & ! Standard deviation of Nc   [#/kg]
!     corr_tNc, & ! Correlation between t and Nc [-]
!     corr_sNc, & ! Correlation between s and Nc [-]
!     covar_tNc1,    & ! Covariance of t and Nc1      []
!     covar_tNc2,    & ! Covariance of t and Nc2      []
!     covar_sNc1,    & ! Covariance of s and Nc1      [# kg/kg^2]
!     covar_sNc2       ! Covariance of s and Nc2      [# kg/kg^2]

!   double precision, dimension(2,2) :: corr_st_mellor_1, corr_st_mellor_2

    ! rr = specific rain content. [rr] = kg rain / kg air
    double precision :: &
      rrainm, &  ! rain water mixing ratio         [kg/kg]
      var_rr1, & ! PDF param for width of plume 1     [(kg/kg)^2]
      var_rr2    ! PDF param for width of plume 2.    [(kg/kg)^2]

    double precision :: &
      tp2_mellor_2, sp2_mellor_2,  & ! Variance of s,t         [(kg/kg)^2]
      sptp_mellor_2,               & ! Covariance of s and t   [kg/kg]
      tp2_mellor_1, sp2_mellor_1,  & ! Variance of s,t         [(kg/kg)^2]
      sptp_mellor_1                  ! Covariance of s and t   [kg/kg]


    double precision, dimension(d_variables,d_variables) :: &
      Sigma1_Cholesky, Sigma2_Cholesky ! Cholesky factorization of Sigma1,2

    double precision, dimension(d_variables) :: &
       Sigma1_scaling, & ! Scaling factors for Sigma1 for accuracy [units vary]
       Sigma2_scaling    ! Scaling factors for Sigma2 for accuracy [units vary]

    logical :: &
      l_Sigma1_scaling, l_Sigma2_scaling ! Whether we're scaling Sigma1 or Sigma2

    double precision, dimension(d_variables,d_variables) :: &
      Corr_stw_1, Corr_stw_2 ! Correlation matrix for Sigma_stw_1,2

    double precision, dimension(:,:), allocatable :: &
      corr_stw_matrix ! Correlation matrix      [-]

    double precision, dimension(3) :: &
      temp_3_elements

    real, pointer, dimension(:) :: &
      xp2_on_xm2_array => null() ! Pointer for the x'2 / xm^2 array

    real, pointer, dimension(:,:) :: &
      corr_array => null()  ! Correlation array pointer

    double precision, pointer, dimension(:,:) :: &
      corr_stw_matrix_Cholesky => null() ! Pointer to the correct Cholesky factorization

    logical :: l_in_cloud

    integer :: i, index1, index2, ivar1, ivar2

    ! ---- Begin Code ----

    ! Determine which variables are a lognormal distribution
    i = max( iiLH_s_mellor, iiLH_t_mellor, iiLH_w )
    l_d_variable_lognormal(1:i) = .false. ! The 1st 3 variates
    l_d_variable_lognormal(i+1:d_variables) = .true.  ! Hydrometeors

    ! Input pdf parameters.

    if ( l_fix_s_t_correlations ) then

      ! For fixed correlations, these don't appear in the correlation matrix, so
      ! we don't need them to be over some threshold.  In deep convective cases
      ! we don't want e.g. the variance of rt aloft to be rt_tol^2 necessarily.

      ! Set means
      w1 = w1_in
      w2 = w2_in
      rt1 = rt1_in
      rt2 = rt2_in
      thl1 = thl1_in
      thl2 = thl2_in
      s1 = s1_in
      s2 = s2_in

      ! Set variances
      varnce_w1 = varnce_w1_in
      varnce_w2 = varnce_w2_in
      varnce_rt1 = varnce_rt1_in
      varnce_rt2 = varnce_rt2_in
      varnce_thl1 = varnce_thl1_in
      varnce_thl2 = varnce_thl2_in

      ! Set standard deviation of s1/s2
      stdev_s1 = stdev_s1_in
      stdev_s2 = stdev_s2_in
    else
      call set_min_varnce_and_mean &
          ( wm, w_tol_sqd, w1_in, varnce_w1_in, & ! In
            varnce_w1, w1 ) ! Out

      call set_min_varnce_and_mean &
          ( wm, w_tol_sqd, w2_in, varnce_w2_in, & ! In
            varnce_w2, w2 ) ! Out

      rtm = rvm + rcm

      call set_min_varnce_and_mean &
          ( rtm, rt_tol**2, rt1_in, varnce_rt1_in, & ! In
            varnce_rt1, rt1 ) ! Out

      call set_min_varnce_and_mean &
          ( rtm, rt_tol**2, rt2_in, varnce_rt2_in, & ! In
            varnce_rt2, rt2 ) ! Out

      call set_min_varnce_and_mean &
          ( thlm, thl_tol**2, thl1_in, varnce_thl1_in, & ! In
            varnce_thl1, thl1 ) ! Out

      call set_min_varnce_and_mean &
          ( thlm, thl_tol**2, thl2_in, varnce_thl2_in, & ! In
            varnce_thl2, thl2 ) ! Out

      ! Compute the mean of s1 and s2
      s_mellor = s1_in * mixt_frac + (1.0-mixt_frac) * s2_in

      ! Here the subroutine name is a little misleading since we're imposing the
      ! threshold on a standard deviation rather than a variance.
      call set_min_varnce_and_mean &
          ( s_mellor, s_mellor_tol, s1_in, stdev_s1_in, & ! In
            stdev_s1, s1 ) ! Out

      ! See comment above.
      call set_min_varnce_and_mean &
          ( s_mellor, s_mellor_tol, s2_in, stdev_s2_in, & ! In
            stdev_s2, s2 ) ! Out
    end if ! l_fix_s_t_correlations

!   cloud_frac1 = dble( cloud_frac1_in )
!   cloud_frac2 = dble( cloud_frac2_in )
    ! Sample non-cloudy grid boxes as well -dschanen 3 June 2009
    cloud_frac1 = 1.0
    cloud_frac2 = 1.0

    !---------------------------------------------------------------------------
    ! Generate a set of sample points for a microphysics scheme
    !---------------------------------------------------------------------------

    ! We prognose rt-thl-w,
    !    but we set means, covariance of hydrometeors (e.g. rrain, Nc) to constants.


    ! Standard sample for testing purposes when n=2
    ! X_u_one_lev(1,1:(d+1)) = ( / 0.0001d0, 0.46711825945881d0, &
    !             0.58015016959859d0, 0.61894015386778d0, 0.1d0, 0.1d0  / )
    ! X_u_one_lev(2,1:(d+1)) = ( / 0.999d0, 0.63222458307464d0, &
    !             0.43642762850981d0, 0.32291562498749d0, 0.1d0, 0.1d0  / )

    ! Select the in-cloud or out of cloud values if the correlations and
    ! x'^2 /  xm^2 terms.

    if ( rcm > rc_tol ) then
      xp2_on_xm2_array => xp2_on_xm2_array_cloud
      corr_array => corr_array_cloud
      l_in_cloud = .true.
    else
      xp2_on_xm2_array => xp2_on_xm2_array_below
      corr_array => corr_array_below
      l_in_cloud = .false.
    end if

    ! Compute PDF parameters for Nc, rr.
    ! Assume that Nc, rr obey single-lognormal distributions

    ! Nc  = droplet number concentration.  [Nc] = number / kg air
    ! Ncm  = mean of Nc
    ! Ncp2_on_Ncm2 = variance of Nc divided by Ncm^2
    !  We must have a Ncp2_on_Ncm2 >= machine epsilon
    ! Nc1  = PDF parameter for mean of plume 1. [Nc1] = (#/kg)
    ! Nc2  = PDF parameter for mean of plume 2. [Nc2] = (#/kg)

    if ( iiLH_Nc > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_Nc, dble( hydromet(iiNcm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    ! rr = specific rain content. [rr] = kg rain / kg air
    ! rrainm  = mean of rr; rrp2 = variance of rr, must have rrp2>0.
    ! rr1  = PDF parameter for mean of plume 1. [rr1] = (kg/kg)
    ! rr2  = PDF parameter for mean of plume 2. [rr2] = (kg/kg)

    if ( iiLH_rrain > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_rrain, dble( hydromet(iirrainm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_Nr > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_Nr, dble( hydromet(iiNrm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_rsnow > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_rsnow, dble( hydromet(iirsnowm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_Nsnow > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_Nsnow, dble( hydromet(iiNsnowm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_rice > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_rice, dble( hydromet(iiricem) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_Ni > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_Ni, dble( hydromet(iiNim) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_rgraupel > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_rgraupel, dble( hydromet(iirgraupelm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if

    if ( iiLH_Ngraupel > 0 ) then
      call add_mu_element_LN &
           ( d_variables, iiLH_Ngraupel, dble( hydromet(iiNgraupelm) ), xp2_on_xm2_array, & ! In
             mu1, mu2 ) ! In/out
    end if


    ! Means of s, t, w, Nc, Nr, rr for Gaussians 1 and 2

    mu1((/iiLH_s_mellor,iiLH_t_mellor,iiLH_w/)) &
      = (/ s1, 0., w1 /)
    mu2((/iiLH_s_mellor,iiLH_t_mellor,iiLH_w/)) &
      = (/ s2, 0., w2 /)

    ! An old subroutine, gaus_rotate, couldn't handle large correlations;
    !   I assume the replacement, gaus_condt, has equal trouble.
    !   Therefore we input smaller correlations
    !   The current code uses a Cholesky decomposition, which also cannot handle
    !   a correlation of exactly 1. -dschanen 5 Oct 2010
    ! max_mag_correlation = 0.99 in constants.F90
    rrtthl_reduced = min( max_mag_correlation, max( rrtthl, -max_mag_correlation ) )

    ! Within-plume rt-thl correlation terms with rt in kg/kg
    rrtthl_covar_reduced1 = dble( rrtthl_reduced*sqrt( varnce_rt1*varnce_thl1 ) )
    rrtthl_covar_reduced2 = dble( rrtthl_reduced*sqrt( varnce_rt2*varnce_thl2 ) )

    call rtpthlp_2_sptp( dble( stdev_s1 ), dble( varnce_rt1 ), dble( varnce_thl1 ), & 
                         dble( rrtthl_covar_reduced1 ), dble( crt1 ), dble( cthl1 ), & ! In
                         tp2_mellor_1, sp2_mellor_1, sptp_mellor_1 ) ! Out
    call rtpthlp_2_sptp( dble( stdev_s2 ), dble( varnce_rt2 ), dble( varnce_thl2 ), & 
                         dble( rrtthl_covar_reduced2 ), dble( crt2 ), dble( cthl2 ), & ! In
                         tp2_mellor_2, sp2_mellor_2, sptp_mellor_2 ) ! Out

    if ( .not. l_fix_s_t_correlations ) then
      ! Covariance (not correlation) matrices of rt-thl-w
      !    for Gaussians 1 and 2
      ! For now, assume no within-plume correlation of w with
      !    any other variables.

      ! Sigma_stw_1,2
      Sigma_stw_1 = 0.d0 ! Start with no covariance, and add matrix elements
      Sigma_stw_2 = 0.d0

      ! Convert each Gaussian from rt-thl-w variables to s-t-w vars.

      ! Setup the Sigma matrices for s,t
      Sigma_stw_1(iiLH_s_mellor,iiLH_s_mellor) = sp2_mellor_1
      Sigma_stw_1(iiLH_t_mellor,iiLH_t_mellor) = tp2_mellor_1
      call set_lower_triangular_matrix_dp( 2, iiLH_s_mellor, iiLH_t_mellor, sptp_mellor_1, &
                                           Sigma_stw_1(1:2,1:2) )

      Sigma_stw_2(iiLH_s_mellor,iiLH_s_mellor) = sp2_mellor_2
      Sigma_stw_2(iiLH_t_mellor,iiLH_t_mellor) = tp2_mellor_2
      call set_lower_triangular_matrix_dp( 2, iiLH_s_mellor, iiLH_t_mellor, sptp_mellor_2, &
                                           Sigma_stw_2(1:2,1:2) )
      ! Add the w element
      Sigma_stw_1(iiLH_w,iiLH_w) = dble( varnce_w1 )

      Sigma_stw_2(iiLH_w,iiLH_w) = dble( varnce_w2 )

      if ( iiLH_Nc > 0 ) then
!       Ncm = dble( hydromet(iiNcm) )
        ! var_Nc1,2 = PDF param for width of plume 1,2. [var_Nc1,2] = (#/kg)**2
        var_Nc1 = log( 1. + Xp2_on_Xm2_array(iiLH_Nc) )
        var_Nc2 = var_Nc1
        Sigma_stw_1(iiLH_Nc,iiLH_Nc) = var_Nc1
        Sigma_stw_2(iiLH_Nc,iiLH_Nc) = var_Nc2
      end if

      if ( iiLH_Nr > 0 ) then
        ! var_Nr1,2 = PDF param for width of plume 1,2. [var_Nr1,2] = (#/kg)**2
        var_Nr1 = log( 1. + Xp2_on_Xm2_array(iiLH_Nr) )
        var_Nr2 = var_Nr1
        Sigma_stw_1(iiLH_Nr,iiLH_Nr) = var_Nr1
        Sigma_stw_2(iiLH_Nr,iiLH_Nr) = var_Nr2
      end if

      if ( iiLH_rrain > 0 ) then
        ! var_rr1,2 = PDF param for width of plume 1,2. [var_rr1,2] = (kg/kg)**2
        var_rr1 = log( 1. + Xp2_on_Xm2_array(iiLH_rrain) )
        var_rr2 = var_rr1
        Sigma_stw_1(iiLH_rrain,iiLH_rrain) = var_rr1
        Sigma_stw_2(iiLH_rrain,iiLH_rrain) = var_rr2
      end if

      if ( iiLH_rrain > 0 .and. iiLH_Nr > 0 ) then

        rrainm = dble( hydromet(iirrainm) )
        Nrm = dble( hydromet(iiNrm) )

        index1 = iiLH_rrain
        index2 = iiLH_Nr

        ! Covariance between rain water mixing ratio rain number concentration
        if ( rrainm > dble( rr_tol ) .and. Nrm > dble( Nr_tol ) ) then

          call get_lower_triangular_matrix_sp &
               ( d_variables, index1, index2, corr_array, & ! In
                 corr_rrNr ) ! Out

          call construct_LN_LN_element &
               ( corr_rrNr, xp2_on_xm2_array(index1), xp2_on_xm2_array(index2), & ! In
                 covar_rrNr1 ) ! Out

          ! rr1 = rr2 and Nr1 = Nr2, so we can just set covar_rrNr2 here
          covar_rrNr2 = covar_rrNr1

          call set_lower_triangular_matrix_dp &
               ( d_variables, index1, index2, dble( covar_rrNr1 ), & ! In
                 Sigma_stw_1 ) ! In/out
          call set_lower_triangular_matrix_dp &
               ( d_variables, index1, index2, dble( covar_rrNr2 ), & ! In
                 Sigma_stw_2 ) ! In/out
        end if

        index1 = iiLH_s_mellor
        index2 = iiLH_Nr
        ! Covariances involving s and Nr & rr
        if ( stdev_s1 > s_mellor_tol .and. Nrm > dble( Nr_tol ) ) then
          call get_lower_triangular_matrix_sp &
               ( d_variables, index1, index2, corr_array, & ! In
                 corr_sNr ) ! Out

          ! Covariance between s and rain number conc.
          call construct_gaus_LN_element &
               ( corr_sNr, stdev_s1, xp2_on_xm2_array(index2), & ! In
                 covar_sNr1 ) ! Out

          call set_lower_triangular_matrix_dp &
               ( d_variables, index1, index2, dble( covar_sNr1 ), & ! In
                 Sigma_stw_1 ) ! In/out

          ! Approximate the covariance of t and Nr
          ! This formula relies on the fact that iiLH_s_mellor < iiLH_t_mellor
          covar_tNr1 = ( Sigma_stw_1(iiLH_t_mellor,iiLH_s_mellor) &
            * dble( covar_sNr1 ) ) / dble( stdev_s1 )**2

          call set_lower_triangular_matrix_dp &
               ( d_variables, iiLH_t_mellor, iiLH_Nr, dble( covar_tNr1 ), & ! In
                 Sigma_stw_1 ) ! In/out
        end if

        if ( stdev_s2 > s_mellor_tol .and. Nrm > dble( Nr_tol ) ) then

          call get_lower_triangular_matrix_sp &
               ( d_variables, index1, index2, corr_array, & ! In
                 corr_sNr ) ! Out

          call construct_gaus_LN_element &
               ( corr_sNr, stdev_s2, xp2_on_xm2_array(index2), & ! In
                 covar_sNr2 ) ! Out

          call set_lower_triangular_matrix_dp &
               ( d_variables, index1, index2, dble( covar_sNr2 ), & ! In
                 Sigma_stw_2 ) ! In/out

          ! Approximate the covariance of t and Nr
          ! This formula relies on the fact that iiLH_s_mellor < iiLH_t_mellor
          covar_tNr2 = ( Sigma_stw_2(iiLH_t_mellor,iiLH_s_mellor) &
            * dble( covar_sNr2 ) ) / dble( stdev_s2 )**2

          call set_lower_triangular_matrix_dp &
               ( d_variables, iiLH_t_mellor, iiLH_Nr, dble( covar_tNr2 ), & ! In
                 Sigma_stw_2 ) ! In/out
        end if

        index1 = iiLH_s_mellor
        index2 = iiLH_rrain
        ! Covariances involving s and Nr & rr
        if ( stdev_s1 > s_mellor_tol .and. rrainm > dble( rr_tol ) ) then

          call get_lower_triangular_matrix_sp &
               ( d_variables, index1, index2, corr_array, & ! In
                 corr_srr ) ! Out

          ! Covariance between s and rain water mixing ratio
          call construct_gaus_LN_element &
               ( corr_srr, stdev_s1, xp2_on_xm2_array(index2), & ! In
                 covar_srr1 ) ! Out

          call set_lower_triangular_matrix_dp &
               ( d_variables, iiLH_s_mellor, iiLH_rrain, dble( covar_srr1 ), & ! In
                 Sigma_stw_1 ) ! In/out

          ! Approximate the covariance of t and rr
          ! This formula relies on the fact that iiLH_s_mellor < iiLH_t_mellor
          covar_trr1 = ( Sigma_stw_1(iiLH_t_mellor,iiLH_s_mellor) &
            * dble( covar_srr1 ) ) / dble( stdev_s1 )**2

          call set_lower_triangular_matrix_dp &
               ( d_variables, iiLH_t_mellor, iiLH_rrain, dble( covar_trr1 ), & ! In
                 Sigma_stw_1 ) ! In/out
        end if

        if ( stdev_s2 > s_mellor_tol .and. rrainm > dble( rr_tol ) ) then

          call get_lower_triangular_matrix_sp &
               ( d_variables, index1, index2, corr_array, & ! In
                 corr_srr ) ! Out

          call construct_gaus_LN_element &
               ( corr_srr, stdev_s2, xp2_on_xm2_array(index2), & ! In
                 covar_srr2 ) ! Out

          call set_lower_triangular_matrix_dp &
               ( d_variables, index1, index2, dble( covar_srr2 ), & ! In
                 Sigma_stw_2 ) ! In/out

          ! Approximate the covariance of t and rr
          ! This formula relies on the fact that iiLH_s_mellor < iiLH_t_mellor
          covar_trr2 = ( Sigma_stw_2(iiLH_t_mellor,iiLH_s_mellor) &
            * dble( covar_srr2 ) ) / dble( stdev_s2 )**2

          call set_lower_triangular_matrix_dp &
               ( d_variables, iiLH_t_mellor, iiLH_rrain, dble( covar_trr2 ), & ! In
                 Sigma_stw_2 ) ! In/out
        end if

      end if ! if iiLH_rrain > 0 .and. iiLH_Nr > 0

!     if ( iiLH_Nc > 0 ) then

      ! Covariances involving s and Nc (currently disabled)
!       corr_sNc = corr_array(iiLH_s_mellor,iiLH_Nc)
!       stdev_Nc = real( Ncm ) * sqrt( xp2_on_xm2_array(iiLH_Nc) )

!       if ( stdev_s1 > s_mellor_tol .and. Ncm > dble( Nc_tol ) ) then
!         ! The variable s is already Gaussian
!         stdev_sNc1 = corr_gaus_LN_to_cov_gaus &
!                 ( corr_sNc, &
!                   stdev_s1, &
!                   sigma_LN_to_sigma_gaus( xp2_on_xm2_array(iiLH_Nc) ) )

!         Sigma_stw_1(iiLH_s_mellor,iiLH_Nc) = dble( stdev_sNc1 )
!         Sigma_stw_1(iiLH_Nc,iiLH_s_mellor) = dble( stdev_sNc1 )

!         ! Approximate the covariance of t and Nc
!         covar_tNc1 = ( Sigma_stw_1(iiLH_t_mellor,iiLH_s_mellor) * covar_sNc1 ) / stdev_s1**2

!         Sigma_stw_1(iiLH_t_mellor,iiLH_Nc) = dble( covar_tNc1 )
!         Sigma_stw_2(iiLH_Nc,iiLH_t_mellor) = dble( covar_tNc2 )

!       end if

!       if ( stdev_s2 > s_mellor_tol .and. Ncm > dble( Nc_tol ) ) then
!         stdev_sNc2 = corr_gaus_LN_to_cov_gaus &
!                 ( corr_sNc, &
!                   stdev_s2, &
!                   sigma_LN_to_sigma_gaus( xp2_on_xm2_array(iiLH_Nc) ) )

!         Sigma_stw_2(iiLH_s_mellor,iiLH_Nc) = dble( stdev_sNc2 )
!         Sigma_stw_2(iiLH_Nc,iiLH_s_mellor) = dble( stdev_sNc2 )

!         ! Approximate the covariance of t and Nc
!         covar_tNc2 = ( Sigma_stw_2(iiLH_t_mellor,iiLH_s_mellor) * covar_sNc2 ) / stdev_s2**2

!         Sigma_stw_2(iiLH_t_mellor,iiLH_Nc) = dble( stNc2 )
!         Sigma_stw_2(iiLH_Nc,iiLH_t_mellor) = dble( stNc2 )

!       end if

!     end if ! iiLH_Nc > 0

      if ( clubb_at_least_debug_level( 2 ) ) then

        call symm_covar_matrix_2_corr_matrix( d_variables, Sigma_stw_1, Corr_stw_1 )
        call symm_covar_matrix_2_corr_matrix( d_variables, Sigma_stw_2, Corr_stw_2 )

        if ( any( Corr_stw_1 > 1.0 ) .or. any( Corr_stw_1 < -1.0 ) ) then
          write(fstderr,*) "Sigma_stw_1 has a correlation > 1 or < -1"
          call print_lower_triangular_matrix( fstderr, d_variables, real( Corr_stw_1 ) )
        end if
        if ( any( Corr_stw_2 > 1.0 ) .or. any( Corr_stw_2 < -1.0 ) ) then
          write(fstderr,*) "Sigma_stw_2 has a correlation > 1 or < -1"
          call print_lower_triangular_matrix( fstderr, d_variables, real( Corr_stw_2 ) )
        end if

      end if ! clubb_at_least_debug_level( 2 )

      ! Compute cholesky factorization Sigma_stw_1 / Sigma_stw_2
      if ( any( X_mixt_comp_one_lev(1:n_micro_calls) == 1 ) ) then
        call Cholesky_factor( d_variables, Sigma_stw_1, & ! In
                              Sigma1_scaling, Sigma1_Cholesky, l_Sigma1_scaling ) ! Out
      end if

      if ( any( X_mixt_comp_one_lev(1:n_micro_calls) == 2 ) ) then
        call Cholesky_factor( d_variables, Sigma_stw_2, & ! In
                              Sigma2_scaling, Sigma2_Cholesky, l_Sigma2_scaling ) ! Out
      end if

    else ! Using fixed correlations

      ! Compute the Cholesky factorization of the correlations if it's not
      ! already computed.
      if ( .not. l_fixed_corr_initialized ) then

        allocate( corr_stw_matrix(d_variables,d_variables), &
                  corr_stw_cloud_Cholesky(d_variables,d_variables), &
                  corr_stw_below_Cholesky(d_variables,d_variables), &
                  corr_stw_cloud_scaling(d_variables), &
                  corr_stw_below_scaling(d_variables) )

        call construct_corr_stw_matrix &
             ( d_variables, corr_array_cloud, & ! In
               xp2_on_xm2_array_cloud, & ! In
               corr_stw_matrix ) ! Out

        ! Compute choleksy factorization for the correlation matrix (in cloud)
        call Cholesky_factor( d_variables, corr_stw_matrix, & ! In
                              corr_stw_cloud_scaling, corr_stw_cloud_Cholesky, & ! Out
                              l_corr_stw_cloud_scaling ) ! Out

        call construct_corr_stw_matrix &
             ( d_variables, corr_array_below, & ! In
               xp2_on_xm2_array_below, & ! In
               corr_stw_matrix ) ! Out

        ! Compute choleksy factorization for the correlation matrix (out of cloud)
        call Cholesky_factor( d_variables, corr_stw_matrix, & ! In
                              corr_stw_below_scaling, corr_stw_below_Cholesky, & ! Out
                              l_corr_stw_below_scaling ) ! Out

        deallocate( corr_stw_matrix )

        l_fixed_corr_initialized = .true.

      end if

      if ( l_in_cloud ) then
        l_Sigma1_scaling = l_corr_stw_cloud_scaling
        l_Sigma2_scaling = l_corr_stw_cloud_scaling
        corr_stw_matrix_Cholesky => corr_stw_cloud_Cholesky
        Sigma1_scaling = corr_stw_cloud_scaling
        Sigma2_scaling = corr_stw_cloud_scaling
      else
        l_Sigma1_scaling = l_corr_stw_below_scaling
        l_Sigma2_scaling = l_corr_stw_below_scaling
        corr_stw_matrix_Cholesky => corr_stw_below_Cholesky
        Sigma1_scaling = corr_stw_below_scaling
        Sigma2_scaling = corr_stw_below_scaling
      end if
      ! Compute the standard deviation of t_mellor 1,2
      stdev_t1 = sqrt( tp2_mellor_1 )
      stdev_t2 = sqrt( tp2_mellor_2 )

      if ( any( X_mixt_comp_one_lev(1:n_micro_calls) == 1 ) ) then
        Sigma1_Cholesky = 0.

        temp_3_elements = (/ dble( stdev_s1 ), stdev_t1, sqrt( dble( varnce_w1 ) ) /)

        call row_mult_lower_tri_matrix &
             ( 3, temp_3_elements, corr_stw_matrix_Cholesky(1:3,1:3), & ! In
               Sigma1_Cholesky(1:3,1:3) ) ! Out

        do ivar1 = 4, d_variables
          do ivar2 = 4, ivar1
            Sigma1_Cholesky(ivar1,ivar2) = corr_stw_matrix_Cholesky(ivar1,ivar2)
          end do
        end do
      end if ! any( X_mixt_comp_one_lev(1:n) == 1 )

      if ( any( X_mixt_comp_one_lev(1:n_micro_calls) == 2 ) ) then
        Sigma2_Cholesky = 0.

        temp_3_elements = (/ dble( stdev_s2 ), stdev_t2, sqrt( dble( varnce_w2 ) ) /)

        call row_mult_lower_tri_matrix &
             ( 3, temp_3_elements, corr_stw_matrix_Cholesky(1:3,1:3), & ! In
               Sigma2_Cholesky(1:3,1:3) ) ! Out

        do ivar1 = 4, d_variables
          do ivar2 = 4, ivar1
            Sigma2_Cholesky(ivar1,ivar2) = corr_stw_matrix_Cholesky(ivar1,ivar2)
          end do
        end do
      end if ! any( X_mixt_comp_one_lev(1:n) == 2 )

    end if ! l_fix_s_t_correlations

    call sample_points( n_micro_calls, d_variables, dble( mixt_frac ), &  ! In
                        dble( rt1 ), dble( thl1 ), &  ! In
                        dble( rt2 ), dble( thl2 ), &  ! In
                        dble( crt1 ), dble( cthl1 ), &  ! In
                        dble( crt2 ), dble( cthl2 ), &  ! In
                        mu1, mu2, &  ! In
                        cloud_frac1, cloud_frac2, & ! In 
                        l_d_variable_lognormal, & ! In
                        X_u_one_lev, & ! In
                        X_mixt_comp_one_lev, & ! In
                        Sigma1_Cholesky, Sigma2_Cholesky, & ! In
                        Sigma1_scaling, Sigma2_scaling, & ! In
                        l_Sigma1_scaling, l_Sigma2_scaling, & ! In
                        LH_rt, LH_thl, X_nl_one_lev ) ! Out

    return
  end subroutine generate_lh_sample

!---------------------------------------------------------------------------------------------------
  subroutine sample_points( n_micro_calls, d_variables, mixt_frac, & 
                            rt1, thl1, rt2, thl2, & 
                            crt1, cthl1, crt2, cthl2, & 
                            mu1, mu2,  & 
                            cloud_frac1, cloud_frac2, & 
                            l_d_variable_lognormal, &
                            X_u_one_lev, &
                            X_mixt_comp_one_lev, &
                            Sigma1_Cholesky, Sigma2_Cholesky, &
                            Sigma1_scaling, Sigma2_scaling, & 
                            l_Sigma1_scaling, l_Sigma2_scaling, &
                            LH_rt, LH_thl, X_nl_one_lev )

! Description:
!   Generates n random samples from a d-dim Gaussian-mixture PDF.
!   Uses Latin hypercube method.

!   Original formulation takes samples only from the cloudy part of the grid box.
!   Revised formulation samples in and out of cloud.

!   We use MKS units on all variates.

! References:
!   None
!----------------------------------------------------------------------

    use latin_hypercube_arrays, only: &
      iiLH_s_mellor, & ! Variables
      iiLH_t_mellor

    implicit none

    ! Input variables
    integer, intent(in) :: &
      n_micro_calls, & ! `n'   Number of calls to microphysics (normally=2)
      d_variables      ! Number of variates (normally=5)

    ! Weight of 1st Gaussian, 0 <= mixt_frac <= 1
    double precision, intent(in) :: mixt_frac

    !rt1, thl1 = mean of rt, thl for Gaus comp 1
    !rt2, thl2 = mean of rt, thl for Gaus comp 2
    double precision, intent(in) :: rt1, thl1, rt2, thl2

    ! Thermodynamic constants for plumes 1 and 2, units of kg/kg
    double precision, intent(in) :: &
      crt1,  & ! coefficient relating rt, s and t for Gaus comp 1
      cthl1, & ! coeff relating thl, s and t for component 1
      crt2,  & ! coefficient relating rt, s and t for component 2
      cthl2    ! coefficient relating thl, s and t for comp. 2

    ! Latin hypercube variables, i.e. s, t, w, etc.
    real, intent(in), dimension(d_variables) :: &
      mu1, mu2 ! d-dimensional column vector of means of 1st, 2nd components

    ! Cloud fractions for components 1 and 2
    double precision, intent(in) :: &
      cloud_frac1, cloud_frac2 ! cloud fraction associated w/ 1st, 2nd mixture component

    logical, intent(in), dimension(d_variables) :: &
      l_d_variable_lognormal ! Whether a given element of X_nl is lognormal

    double precision, intent(in), dimension(n_micro_calls,d_variables+1) :: &
      X_u_one_lev ! Sample drawn from uniform distribution from particular grid level [-]

    integer, intent(in), dimension(n_micro_calls) :: &
      X_mixt_comp_one_lev ! Whether we're in the 1st or 2nd mixture component

    ! Columns of Sigma_Cholesky, X_nl_one_lev:  1   2   3   4 ... d_variables
    !                                           s   t   w   hydrometeors
    double precision, intent(in), dimension(d_variables,d_variables) :: &
      Sigma1_Cholesky, & ! [units vary]
      Sigma2_Cholesky

    double precision, intent(in), dimension(d_variables) :: &
      Sigma1_scaling, Sigma2_scaling ! Scaling factors on Sigma1,2 [units vary]

    logical, intent(in) :: &
      l_Sigma1_scaling, l_Sigma2_scaling ! Whether we're scaling Sigma1 or Sigma2

    ! Output Variables
    ! Total water, theta_l: mean plus perturbations
    real, intent(out), dimension(n_micro_calls) :: &
      LH_rt,  & ! Total water   [kg/kg]
      LH_thl    ! Liquid potential temperature  [K]

    double precision, intent(out), dimension(n_micro_calls,d_variables) :: &
      X_nl_one_lev ! Sample that is transformed ultimately to normal-lognormal

    ! Local Variables
    integer :: sample

    ! ---- Begin Code ----

    sample = 1       ! These lines prevent a g95 compiler error for uninitialized variable and
    sample = sample  ! unused variable. -meyern

    ! Generate n samples of a d-variate Gaussian mixture
    ! by transforming Latin hypercube points, X_u_one_lev.
    call gaus_mixt_points( n_micro_calls, d_variables, mixt_frac, mu1, mu2, &  ! In
                           Sigma1_Cholesky, Sigma2_Cholesky, & ! In
                           Sigma1_scaling, Sigma2_scaling, & ! In
                           l_Sigma1_scaling, l_Sigma2_scaling, & ! In
                           cloud_frac1, cloud_frac2, X_u_one_lev, & ! In
                           X_mixt_comp_one_lev, & ! In
                           X_nl_one_lev ) ! Out

! Transform s (column 1) and t (column 2) back to rt and thl
! This is only needed if you need rt, thl in your microphysics.
!     call sptp_2_rtpthlp &
!          ( n_micro_calls, d_variables, mixt_frac, crt1, cthl1, crt2, cthl2, &
!            cloud_frac1, cloud_frac2, X_nl_one_lev(1:n_micro_calls,1), &
!            X_nl_one_lev(1:n_micro_calls,2), &
!            X_u_one_lev, rtp, thlp )
    call st_2_rtthl( n_micro_calls, mixt_frac, rt1, thl1, rt2, thl2, & ! In
                     crt1, cthl1, crt2, cthl2, & ! In
                     cloud_frac1, cloud_frac2, mu1(iiLH_s_mellor), mu2(iiLH_s_mellor), & ! In
                     X_nl_one_lev(1:n_micro_calls,iiLH_s_mellor), & ! In
                     X_nl_one_lev(1:n_micro_calls,iiLH_t_mellor), & ! In
                     X_mixt_comp_one_lev, & ! In
                     LH_rt, LH_thl ) ! Out
    ! Convert lognormal variates (e.g. Nc and rr) to lognormal
    forall ( sample = 1:n_micro_calls )
      where ( l_d_variable_lognormal )
        X_nl_one_lev(sample,:) = exp( X_nl_one_lev(sample,:) )
      end where
    end forall

    return
  end subroutine sample_points

!-------------------------------------------------------------------------------

!-----------------------------------------------------------------------
  subroutine rtpthlp_2_sptp( stdev_s_mellor, varnce_rt, varnce_thl, &
                             rrtthl_covar, crt, cthl, &
                             tp2, sp2, sptp ) ! Out

! Description:
!   Transform covariance matrix from rt', theta_l' coordinates
!   to s', t' coordinates.
!   Use linear approximation for s', t'.
! References:
!   ``Supplying Local Microphysics Parameterizations with Information about
!     Subgrid Variability: Latin Hypercube Sampling'', V.E. Larson et al.,
!     JAS 62 pp. 4015
!-----------------------------------------------------------------------

    use constants_clubb, only: &
      max_mag_correlation ! Constant

    implicit none

    ! External
    intrinsic :: min, max, sqrt

    ! Input Variables

    double precision, intent(in) :: &
      stdev_s_mellor, & ! Standard deviation of s_mellor [(kg/kg)^2]
      varnce_rt,      & ! Variance of rt1/rt2
      varnce_thl,     & ! Variance of thl1/thl2
      rrtthl_covar,   & ! Covariance of rt, thl
      crt, cthl         ! Coefficients that define s', t'

    ! Output Variables

    double precision, intent(out) :: &
      tp2, sp2,  &    ! Variance of s,t         [(kg/kg)^2]
      sptp            ! Covariance of s and t   [kg/kg]

    ! Local Variables

    double precision :: crt_sqd, cthl_sqd

    double precision :: &
      sqrt_sp2_tp2 ! sqrt of the product of the variances of s and t [kg/kg]

    ! ---- Begin Code ----

    ! Simplified formula. Here we compute the variance t_mellor and covariance
    ! of s_mellor and t_mellor using formula's derived from the matrix
    ! multiplication on Larson, et al. See figure 14.
    crt_sqd = crt**2
    cthl_sqd = cthl**2
    sptp = crt_sqd * varnce_rt - cthl_sqd * varnce_thl
    tp2 = crt_sqd * varnce_rt + 2.d0 * crt * cthl * rrtthl_covar &
        + cthl_sqd * varnce_thl
    sp2 = stdev_s_mellor**2

    ! Reduce the correlation of s and t Mellor if it's greater than 0.99
    sqrt_sp2_tp2 = sqrt( sp2 * tp2 )
    sptp = min( max( -max_mag_correlation * sqrt_sp2_tp2, sptp ), &
                max_mag_correlation * sqrt_sp2_tp2 )

!   sptp = 0.3 * sqrt( sp2 ) * sqrt( tp2 )

    return
  end subroutine rtpthlp_2_sptp
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
  subroutine generate_uniform_sample( n_micro_calls, nt_repeat, dp1, p_matrix, X_u_one_lev )

! Description:
!   Generates a matrix X that contains a Latin Hypercube sample.
!   The sample is uniformly distributed.
! References:
!   See Art B. Owen (2003), ``Quasi-Monte Carlo Sampling,"
!      a chapter from SIGGRAPH 2003
!-------------------------------------------------------------------------------

    use mt95, only: genrand_real ! Constants

    implicit none

    ! Input Variables
    integer, intent(in) :: &
      n_micro_calls, & ! `n'   Number of calls to microphysics (normally=2)
      nt_repeat,     & ! `n_t' Num. random samples before sequence repeats (normally=10)
      dp1              !  d+1  Number of variates plus 1 (normally=6)

    integer, intent(in), dimension(n_micro_calls,dp1) :: &
      p_matrix    !n x dp1 array of permuted integers

    ! Output Variables

    real(kind=genrand_real), intent(out), dimension(n_micro_calls,dp1) :: &
      X_u_one_lev ! n by dp1 matrix, X, each row of which is a dp1-dimensional sample

    ! Local Variables

    integer :: j, k

    ! ---- Begin Code ----

!  Compute random permutation row by row
!       do j=1,dp1
!       ! Generate a column vector of integers from 0 to n-1,
!       !    whose order is random.
!         call rand_permute( n, p_matrix(1:n,j) )
!       end do

    ! Choose values of sample using permuted vector and random number generator
    do j = 1,n_micro_calls
      do k = 1,dp1
        X_u_one_lev(j,k) = choose_permuted_random( nt_repeat, p_matrix(j,k) )
      end do
    end do

    return
  end subroutine generate_uniform_sample

!----------------------------------------------------------------------
  function choose_permuted_random( nt_repeat, p_matrix_element )

    use mt95, only: genrand_real3 ! Procedure(s)

    use mt95, only: genrand_real ! Constants

    implicit none

    ! Input Variables
    integer, intent(in) :: & 
      nt_repeat,        & ! Number of samples before the sequence repeats
      p_matrix_element    ! Permuted integer

    ! Output Variable
    real(kind=genrand_real) :: choose_permuted_random

    ! Local Variable
    real(kind=genrand_real) :: & 
      rand ! Random float with a range of (0,1)

    ! ---- Begin Code ----

    call genrand_real3( rand ) ! genrand_real3's range is (0,1)

    choose_permuted_random = (1.0_genrand_real/nt_repeat)*(p_matrix_element + rand )

    return
  end function choose_permuted_random

!----------------------------------------------------------------------
  subroutine gaus_mixt_points( n_micro_calls, d_variables, mixt_frac, mu1, mu2, &
                               Sigma1_Cholesky, Sigma2_Cholesky, &
                               Sigma1_scaling, Sigma2_scaling, &
                               l_Sigma1_scaling, l_Sigma2_scaling, &
                               cloud_frac1, cloud_frac2, X_u_one_lev, &
                               X_mixt_comp_one_lev, &
                               X_nl_one_lev )
! Description:
!   Generates n random samples from a d-dimensional Gaussian-mixture PDF.
!   Uses Latin hypercube method.
! References:
!   None
!----------------------------------------------------------------------

    use constants_clubb, only:  &
      fstderr  ! Constant(s)

    use error_code, only:  &
      clubb_at_least_debug_level  ! Procedure(s)

    implicit none

    ! Input Variables

    integer, intent(in) :: &
      n_micro_calls, &  ! Number of calls to microphysics (normally=2) 
      d_variables       ! Number of variates (normally=5)

    double precision, intent(in) :: &
      mixt_frac,     & ! Mixture fraction of Gaussians
      cloud_frac1, cloud_frac2   ! Cloud fraction associated w/ 1st, 2nd mixture component

    real, intent(in), dimension(d_variables) :: &
      mu1, mu2 ! d-dimensional column vector of means of 1st, 2nd Gaussians

    ! Latin hypercube sample from uniform distribution from a particular grid level
    double precision, intent(in), dimension(n_micro_calls,d_variables+1) :: &
      X_u_one_lev

    double precision, dimension(d_variables,d_variables), intent(in) :: &
      Sigma1_Cholesky, Sigma2_Cholesky ! Cholesky factorization of Sigma1,2

    double precision, dimension(d_variables), intent(in) :: &
      Sigma1_scaling, & ! Scaling factors for Sigma1 for accuracy [units vary]
      Sigma2_scaling    ! Scaling factors for Sigma2 for accuracy [units vary]

    logical, intent(in) :: &
      l_Sigma1_scaling, l_Sigma2_scaling ! Whether we're scaling Sigma1 or Sigma2

    integer, intent(in), dimension(n_micro_calls) :: &
      X_mixt_comp_one_lev ! Which mixture component we're in

    ! Output Variables

    double precision, intent(out), dimension(n_micro_calls,d_variables) :: &
      X_nl_one_lev ! [n by d] matrix, each row of which is a d-dimensional sample

    ! Local Variables

    double precision, dimension(d_variables) :: &
      std_normal  ! Standard normal multiplied by the factorized Sigma    [-]

    integer :: ivar, sample ! Loop iterators

    ! ---- Begin Code ----

    ! Handle some possible errors re: proper ranges of mixt_frac,
    ! cloud_frac1, cloud_frac2.
    if (mixt_frac > 1.0d0 .or. mixt_frac < 0.0d0) then
      write(fstderr,*) 'Error in gaus_mixt_points:  ',  &
                       'mixture fraction, mixt_frac, does not lie in [0,1].'
      stop
    end if
    if (cloud_frac1 > 1.0d0 .or. cloud_frac1 < 0.0d0) then
      write(fstderr,*) 'Error in gaus_mixt_points:  ',  &
                       'cloud fraction 1, cloud_frac1, does not lie in [0,1].'
      stop
    end if
    if (cloud_frac2 > 1.0d0 .or. cloud_frac2 < 0.0d0) then
      write(fstderr,*) 'Error in gaus_mixt_points:  ',  &
                       'cloud fraction 2, cloud_frac2, does not lie in [0,1].'
      stop
    end if

    ! Make sure there is some cloud.
    if (mixt_frac*cloud_frac1 < 0.001d0 .and. (1-mixt_frac)*cloud_frac2 < 0.001d0) then
      if ( clubb_at_least_debug_level( 1 ) ) then
        write(fstderr,*) 'Error in gaus_mixt_points:  ',  &
                         'there is no cloud or almost no cloud!'
      end if
    end if

    do sample = 1, n_micro_calls

      ! From Latin hypercube sample, generate standard normal sample
      do ivar = 1, d_variables
        std_normal(ivar) = ltqnorm( X_u_one_lev(sample,ivar) )
      end do

      ! Determine which mixture fraction we are in.
      if ( X_mixt_comp_one_lev(sample) == 1 ) then

        call multiply_Cholesky &
            ( d_variables, std_normal, mu1, Sigma1_Cholesky, &  ! In
              Sigma1_scaling, l_Sigma1_scaling, & ! In
              X_nl_one_lev(sample, 1:d_variables) ) ! Out

      else if ( X_mixt_comp_one_lev(sample) == 2 ) then

        call multiply_Cholesky &
             ( d_variables, std_normal, mu2, Sigma2_Cholesky, &  ! In
               Sigma2_scaling, l_Sigma2_scaling, & ! In
               X_nl_one_lev(sample, 1:d_variables) ) ! Out

      else
        stop "Error determining mixture component in gaus_mixt_points"

      end if ! X_mixt_comp_one_lev(sample)

      ! Loop to get new sample
    end do

    return
  end subroutine gaus_mixt_points

!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
  subroutine truncate_gaus_mixt( n_micro_calls, d_variables, col, mixt_frac, mu1, mu2, & 
                  Sigma1, Sigma2, cloud_frac1, cloud_frac2, X_u_one_lev, &
                  X_mixt_comp_one_lev, truncated_column )
! Description:
!   Converts sample points drawn from a uniform distribution
!    to truncated Gaussian points.
! References:
!   None
!-------------------------------------------------------------------------------

    use constants_clubb, only:  &
      fstderr  ! Constant(s)

    use error_code, only:  &
      clubb_at_least_debug_level  ! Procedure(s)

    implicit none

    ! Input Variables

    integer, intent(in) :: &
      n_micro_calls, &  ! Number of calls to microphysics (normally=2) 
      d_variables,   &  ! Number of variates (normally=5)
      col               ! Scalar indicated which column of X_nl_one_lev to truncate

    double precision, intent(in) :: &
      mixt_frac,    & ! Mixture fraction of Gaussians
      cloud_frac1, cloud_frac2  ! Cloud fraction associated w/ 1st, 2nd mixture component

    real, intent(in), dimension(d_variables) :: &
      mu1, mu2 ! d-dimensional column vector of means of 1st, 2nd Gaussians

    double precision, intent(in), dimension(d_variables,d_variables) :: &
      Sigma1, Sigma2 ! dxd dimensional covariance matrices

    ! Latin hypercube sample from uniform distribution from a particular grid level
    double precision, intent(in), dimension(n_micro_calls,d_variables+1) :: &
      X_u_one_lev

    integer, intent(in), dimension(n_micro_calls) :: &
      X_mixt_comp_one_lev ! Whether we're in the first or second mixture component

    ! Output Variables

    ! A column vector of length n that is transformed from a Gaussian PDF to truncated Gaussian PDF.
    double precision, intent(out), dimension(n_micro_calls) :: truncated_column

    ! Local Variables

    integer :: sample
    double precision :: s_std

    ! ---- Begin Code ----

    ! Handle some possible errors re: proper ranges of mixt_frac,
    ! cloud_frac1, cloud_frac2.
    if ( (mixt_frac > 1.0d0) .or. (mixt_frac < 0.0d0) ) then
      write(fstderr,*) 'Error in truncate_gaus_mixt:  ',  &
                       'mixture fraction, mixt_frac, does not lie in [0,1].'
      stop
    end if
    if ( (cloud_frac1 > 1.0d0) .or. (cloud_frac1 < 0.0d0) ) then
      write(fstderr,*) 'Error in truncate_gaus_mixt:  ',  &
                       'cloud fraction 1, cloud_frac1, does not lie in [0,1].'
      stop
    end if
    if ( (cloud_frac2 > 1.0d0) .or. (cloud_frac2 < 0.0d0) ) then
      write(fstderr,*) 'Error in truncate_gaus_mixt:  ',  &
                       'cloud fraction 2, cloud_frac2, does not lie in [0,1].'
      stop
    end if

    ! Make sure there is some cloud.
    if (mixt_frac*cloud_frac1 < 0.001d0 .and. (1-mixt_frac) * cloud_frac2 < 0.001d0) then
      if ( clubb_at_least_debug_level( 1 ) ) then
        write(fstderr,*) 'Error in truncate_gaus_mixt:  ',  &
                         'there is no cloud or almost no cloud!'
      end if
    end if

    ! Make s PDF (1st column) a truncated Gaussian.
    ! This allows us to sample solely from the cloud points.
    do sample = 1, n_micro_calls

      ! Choose which mixture fraction we are in.
      ! Account for cloud fraction.
      ! Follow M. E. Johnson (1987), p. 56.
      if  ( X_mixt_comp_one_lev(sample) == 1 ) then
        ! Replace first dimension (s) with
        !  sample from cloud (i.e. truncated standard Gaussian)
        s_std = ltqnorm( X_u_one_lev( sample, col ) * cloud_frac1 + (1.d0 - &
          cloud_frac1) )
        ! Convert to nonstandard normal with mean mu1 and variance Sigma1
        truncated_column(sample) =  & 
                   s_std * sqrt( Sigma1(col,col) ) + mu1(col)
      else if ( X_mixt_comp_one_lev(sample) == 2 ) then

        ! Replace first dimension (s) with
        !   sample from cloud (i.e. truncated Gaussian)
        s_std = ltqnorm( X_u_one_lev( sample, col ) * cloud_frac2 + (1.d0 - &
          cloud_frac2) )

        ! Convert to nonstandard normal with mean mu2 and variance Sigma2
        truncated_column(sample) =  & 
                      s_std * sqrt( Sigma2(col,col) ) + mu2(col)
      else
        stop "Error in truncate_gaus_mixt"
      end if

      ! Loop to get new sample
    end do

    return
  end subroutine truncate_gaus_mixt

!-----------------------------------------------------------------------
  double precision function ltqnorm( p )
! Description:
!   This function is ported to Fortran from the same function written in Matlab, see the following
!   description of this function.  Hongli Jiang, 2/17/2004
!   Converted to double precision by Vince Larson 2/22/2004;
!    this improves results for input values of p near 1.

! LTQNORM Lower tail quantile for standard normal distribution.
!
!   Z = LTQNORM(P) returns the lower tail quantile for the standard normal
!   distribution function.  I.e., it returns the Z satisfying Pr{X < Z} = P,
!   where X has a standard normal distribution.
!
!   LTQNORM(P) is the same as SQRT(2) * ERFINV(2*P-1), but the former returns a
!   more accurate value when P is close to zero.

!   The algorithm uses a minimax approximation by rational functions and the
!   result has a relative error less than 1.15e-9.  A last refinement by
!   Halley's rational method is applied to achieve full machine precision.

!   Author:      Peter J. Acklam
!   Time-stamp:  2003-04-23 08:26:51 +0200
!   E-mail:      pjacklam@online.no
!   URL:         http://home.online.no/~pjacklam
!-----------------------------------------------------------------------

    use constants_clubb, only: Pi_DP ! Variable(s)

    implicit none

    ! External

    intrinsic :: log, sqrt

    ! Input Variable(s)

    double precision, intent(in) :: p


    ! Local Variable(s)

    double precision a1, a2, a3, a4, a5, a6, b1, b2, b3, b4, b5, & 
                     c1, c2, c3, c4, c5, c6, d1, d2, d3, d4

    double precision q, r, z, z1, plow, phigh

!       double preciseion e, erf_dp, u

!       Occurs in constants.F now.  Isn't actually used currently.
!        double precision, parameter :: pi=3.1415926d0

! Coefficients in rational approximations.
! equivalent: a(1)=a1, a(2)=a2, and etc, when a(1) is in Matlab.
! Similarly for b, c, and d's
    parameter (a1 = -3.969683028665376d+01,  & 
               a2 = 2.209460984245205d+02, & 
               a3 = -2.759285104469687d+02,  & 
               a4 = 1.383577518672690d+02, & 
               a5 = -3.066479806614716d+01,  & 
               a6 = 2.506628277459239d+00)
    parameter (b1 = -5.447609879822406d+01,  & 
               b2 = 1.615858368580409d+02, & 
               b3 = -1.556989798598866d+02,  & 
               b4 = 6.680131188771972d+01, & 
               b5 = -1.328068155288572d+01)
    parameter (c1 = -7.784894002430293d-03,  & 
               c2 = -3.223964580411365d-01, & 
               c3 = -2.400758277161838d+00,  & 
               c4 = -2.549732539343734d+00, & 
               c5 =  4.374664141464968d+00,  & 
               c6 =  2.938163982698783d+00)
    parameter (d1 =  7.784695709041462d-03,  & 
               d2 =  3.224671290700398d-01, & 
               d3 =  2.445134137142996d+00,  & 
               d4 =  3.754408661907416d+00)

    ! Default initialization
    z = 0.0

!  Define break-points.
    plow  = 0.02425d0
    phigh = 1.d0 - plow

!  Initialize output array. Don't need this in Fortran
!   z = zeros(size(p));

!  Rational approximation for lower region:
    if (p > 0.d0 .and. p < plow) then
      q = sqrt( -2 * log(p) )
      z = (((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6)/ & 
                ((((d1*q+d2)*q+d3)*q+d4)*q+1.d0)
!  Rational approximation for central region:
    else if (p >= plow .and. p <= phigh) then
      q = p - 0.5d0
      r = q * q
      z = (((((a1*r+a2)*r+a3)*r+a4)*r+a5)*r+a6)*q & 
                 /(((((b1*r+b2)*r+b3)*r+b4)*r+b5)*r+1.d0)
! Rational approximation for upper region:
    else if (p > phigh .and. p < 1.d0) then
      q  = sqrt( -2.d0 * log(1.d0 - p) )
      z  = -(((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6) & 
                  /((((d1*q+d2)*q+d3)*q+d4)*q+1.d0)
    end if

!  Case when P = 0: z = -inf, to create inf z =-1./0.,
!     to create NaN's inf*inf.
    z1 = 0.d0
    if (p == 0.d0) then
      z = (-1.d0)/z1
    end if

! Case when P = 1:, z=inf
    if(p == 1.d0)then
      z = 1.d0/z1
    end if

!  Cases when output will be NaN:
!   k = p < 0 | p > 1 | isnan(p);
! usually inf*inf --> NaN's.
    if (p < 0.d0 .or. p > 1d0) then
      z = (1.d0/z1)**2
    end if

!  The relative error of the approximation has absolute value less
!  than 1.15e-9.  One iteration of Halley's rational method (third
!  order) gives full machine precision.
! V. Larson 20Feb04: Don't use the following if-end if loop.
!   The value of e is very different than what MATLAB produces,
!   possibly because of
!   poor values of erf from Numerical Recipes.
!   The value is close to MATLAB's
!   if I omit the following if-end if loop.
! End V. Larson comment
!!   k = 0 < p & p < 1;
!       if (p.gt.0 .and. p.lt.1)then
!         e = 0.5*(1.0 - erf_dp(-z/sqrt(2.))) - p          ! error
!         u = e * sqrt(2*pi_dp) * exp(z**2/2)       ! f(z)/df(z)
!         z = z - u/( 1 + z*u/2 )               ! Halley's method
!       end if

! return z as double precision:
    ltqnorm = z

    return
  end function ltqnorm

!-------------------------------------------------------------------------------
  subroutine multiply_Cholesky( d_variables, std_normal, mu, Sigma_Cholesky, & 
                                  Sigma_scaling, l_scaled, &
                                  nonstd_normal )
! Description:
!   Computes the nonstd_normal from the Cholesky factorization of Sigma,
!   std_normal, and mu.
!   nonstd_normal = Sigma_Cholesky * std_normal + mu.

! References:
!   M. E. Johnson (1987), ``Multivariate Normal and Related Distributions'' p50-55
!-------------------------------------------------------------------------------

    implicit none

    ! External
    intrinsic :: dble

    external :: dtrmv ! BLAS upper/lower triangular multiplication subroutine

    ! Parameters
    integer, parameter :: &
      incx = 1 ! Increment for x in dtrmv

    ! Input Variables
    integer, intent(in) :: d_variables ! Number of variates (normally=5)

    double precision, intent(in), dimension(d_variables) :: &
      std_normal ! vector of d-variate standard normal distribution [-]

    real, intent(in), dimension(d_variables) :: &
      mu ! d-dimensional column vector of means of Gaussian     [units vary]

    double precision, intent(in), dimension(d_variables,d_variables) :: &
      Sigma_Cholesky ! Cholesky factorization of the Sigma matrix [units vary]

    double precision, intent(in), dimension(d_variables) :: &
      Sigma_scaling ! Scaling for Sigma / mu    [units vary]

    logical, intent(in) :: l_scaled ! Whether any scaling was done to Sigma

    ! Output Variables

    ! nxd matrix of n samples from d-variate normal distribution
    !   with mean mu and covariance structure Sigma
    double precision, intent(out) :: &
      nonstd_normal(d_variables)

    ! Local Variables
    double precision, dimension(d_variables) :: &
      Sigma_times_std_normal ! Sigma * std_normal [units vary]

    ! --- Begin Code ---

    Sigma_times_std_normal = std_normal ! Copy std_normal into 'x'

    ! Call the level 2 BLAS subroutine to multiply std_normal by Sigma_Cholesky
    call dtrmv( 'Lower', 'N', 'N', d_variables, Sigma_Cholesky, d_variables, & ! In
                Sigma_times_std_normal, & ! In/out
                incx ) ! In

    if ( l_scaled ) then
      ! Add mu to Sigma * std_normal (scaled)
      nonstd_normal = Sigma_times_std_normal + dble( mu ) * Sigma_scaling
      ! Determine 'y' vector by removing the scaling factors
      nonstd_normal = nonstd_normal / Sigma_scaling
    else
      ! Add mu to Sigma * std_normal
      nonstd_normal = Sigma_times_std_normal + dble( mu )
    end if

    return
  end subroutine multiply_Cholesky
!-----------------------------------------------------------------------
  subroutine st_2_rtthl( n_micro_calls, mixt_frac, rt1, thl1, rt2, thl2, & 
                         crt1, cthl1, crt2, cthl2, & 
                         cloud_frac1, cloud_frac2, mu_s1, mu_s2, &
                         s_mellor, t_mellor, X_mixt_comp_one_lev, &
                         LH_rt, LH_thl )
! Description:
!   Converts from s, t variables to rt, thl
! References:
!   None
!-----------------------------------------------------------------------

    use constants_clubb, only:  &
        fstderr  ! Constant(s)

    use error_code, only:  &
        clubb_at_least_debug_level  ! Procedure(s)

    implicit none

    ! Input

    integer, intent(in) :: &
      n_micro_calls   ! Number of calls to microphysics (normally=2)

    double precision, intent(in) :: &
      mixt_frac,   & ! Mixture fraction of Gaussians 'mixt_frac' [-]
      rt1, rt2,    & ! n dimensional column vector of rt         [kg/kg]
      thl1, thl2,  & ! n dimensional column vector of thetal     [K]
      crt1, crt2,  & ! Constants from plumes 1 & 2 of rt
      cthl1, cthl2   ! Constants from plumes 1 & 2 of thetal

    double precision, intent(in) :: &
      cloud_frac1, cloud_frac2 ! Cloud fraction associated with 1st / 2nd mixture component

    real, intent(in) :: &
      mu_s1, mu_s2

    ! n-dimensional column vector of Mellor's s and t, including mean and perturbation
    double precision, intent(in), dimension(n_micro_calls) :: &
      s_mellor, & 
      t_mellor

    integer, dimension(n_micro_calls), intent(in) :: &
      X_mixt_comp_one_lev ! Whether we're in the first or second mixture component

    ! Output variables

    real, dimension(n_micro_calls), intent(out) :: &
      LH_rt, LH_thl ! n-dimensional column vectors of rt and thl, including mean and perturbation

    ! Local

    integer :: sample

    ! ---- Begin Code ----

    ! Handle some possible errors re: proper ranges of mixt_frac,
    ! cloud_frac1, cloud_frac2.

    if ( mixt_frac > 1.0d0 .or. mixt_frac < 0.0d0 ) then
      write(fstderr,*) 'Error in st_2_rtthl:  ',  &
                       'mixture fraction, mixt_frac, does not lie in [0,1].'
      stop
    end if
    if ( cloud_frac1 > 1.0d0 .or. cloud_frac1 < 0.0d0 ) then
      write(fstderr,*) 'Error in st_2_rtthl:  ',  &
                       'cloud fraction 1, cloud_frac1, does not lie in [0,1].'
      stop
    end if
    if ( cloud_frac2 > 1.0d0 .or. cloud_frac2 < 0.0d0 ) then
      write(fstderr,*) 'Error in st_2_rtthl:  ',  &
                       'cloud fraction 2, cloud_frac2, does not lie in [0,1].'
      stop
    end if

    ! Make sure there is some cloud.
    if ( mixt_frac*cloud_frac1 < 0.001d0 .and. (1-mixt_frac)*cloud_frac2 < 0.001d0 ) then
      if ( clubb_at_least_debug_level( 1 ) ) then
        write(fstderr,*) 'Error in st_2_rtthl:  ',  &
                         'there is no cloud or almost no cloud!'
      end if
    end if

    do sample = 1, n_micro_calls

      ! Choose which mixture fraction we are in.
      ! Account for cloud fraction.
      ! Follow M. E. Johnson (1987), p. 56.
!     fraction_1     = mixt_frac*cloud_frac1 / &
!                      (mixt_frac*cloud_frac1+(1-mixt_frac)*cloud_frac2)

!     if ( in_mixt_frac_1( X_u_one_lev(sample,d_variables+1), fraction_1 ) ) then
      if ( X_mixt_comp_one_lev(sample) == 1 ) then
        LH_rt(sample)  = real( rt1 + (0.5d0/crt1)*(s_mellor(sample)-mu_s1) +  & 
                               (0.5d0/crt1)*t_mellor(sample) )
        LH_thl(sample) = real( thl1 + (-0.5d0/cthl1)*(s_mellor(sample)-mu_s1) +  & 
                               (0.5d0/cthl1)*t_mellor(sample) )

      else if ( X_mixt_comp_one_lev(sample) == 2 ) then
        ! mixture fraction 2
        LH_rt(sample)  = real( rt2 + (0.5d0/crt2)*(s_mellor(sample)-mu_s2) +  & 
                               (0.5d0/crt2)*t_mellor(sample) )
        LH_thl(sample) = real( thl2 + (-0.5d0/cthl2)*(s_mellor(sample)-mu_s2) +  & 
                              (0.5d0/cthl2)*t_mellor(sample) )

      else
        stop "Error determining mixture fraction in st_2_rtthl"

      end if

      ! Loop to get new sample
    end do

    return
  end subroutine st_2_rtthl
!-------------------------------------------------------------------------------
  subroutine log_sqd_normalized( Xm, Xp2_on_Xm2, &
                                 X1, X2 )
! Description:
!
! References:
!   None
!-------------------------------------------------------------------------------
    implicit none

    ! External
    intrinsic :: log, epsilon, max

    ! Input Variables
    double precision, intent(in) :: &
      Xm,         & ! Mean X          [units vary]
      Xp2_on_Xm2    ! X'^2 / X^2      [-]

    ! Output Variables
    double precision, intent(out) :: &
      X1, X2  ! PDF parameters for mean of plume 1, 2   [units vary]

    ! ---- Begin Code ----

    ! Here the variables X1 & X2 have ambiguous units.  After the exp function
    ! is applied to the result at the very end of this code the units will be
    ! correct because of the 0.5 coefficient. I.e. sqrt( Xm^2 ) = Xm.
    ! Here we use epsilon to impose a limit on the numerator to prevent
    ! taking the log of 0 while still imposing an upper bound.
    X1 = 0.5 * log( max( Xm, epsilon( Xm ) )**2 / ( 1. + Xp2_on_Xm2 ) )
    X2 = X1

    return
  end subroutine log_sqd_normalized

!-------------------------------------------------------------------------------
  subroutine construct_gaus_LN_element( corr_sy, stdev_s, yp2_on_ym2, &
                                        covar_sy )

! Description:
!   Compute the covariance of s_mellor and a lognormal variate,
!   converting from lognormal to gaussian space as required.
! References:
!   None
!-------------------------------------------------------------------------------

    implicit none

    real, intent(in) :: &
      corr_sy,   & ! Correlation between x and y [-]
      stdev_s,   & ! Standard deviation of s     [usually kg/kg]
      yp2_on_ym2   ! Variance of y over mean y^2 [-]

    real, intent(out) :: covar_sy

    real :: yp2_on_ym2_gaus

    ! ---- Begin Code ----

    yp2_on_ym2_gaus = sigma_LN_to_sigma_gaus( yp2_on_ym2 )

    covar_sy = corr_gaus_LN_to_cov_gaus( corr_sy, stdev_s, yp2_on_ym2_gaus )

    return
  end subroutine construct_gaus_LN_element
!-------------------------------------------------------------------------------
  subroutine construct_LN_LN_element( corr_xy, xp2_on_xm2, yp2_on_ym2, &
                                      covar_xy )

! Description:
!   Compute the covariance of 2 variables, converting from lognormal
!   to gaussian space as required.
! References:
!   None
!-------------------------------------------------------------------------------

    implicit none

    real, intent(in) :: &
      corr_xy,    & ! Correlation between x and y   [-]
      xp2_on_xm2, & ! Variance of x over mean x^2   [-]
      yp2_on_ym2    ! Variance of y over mean y^2   [-]

    real, intent(out) :: covar_xy

    real :: xp2_on_xm2_gaus, yp2_on_ym2_gaus

    ! ---- Begin Code ----

    xp2_on_xm2_gaus = sigma_LN_to_sigma_gaus( xp2_on_xm2 )
    yp2_on_ym2_gaus = sigma_LN_to_sigma_gaus( yp2_on_ym2 )

    covar_xy = corr_LN_to_cov_gaus( corr_xy, xp2_on_xm2_gaus, yp2_on_ym2_gaus )

    return
  end subroutine construct_LN_LN_element

!-------------------------------------------------------------------------------
  subroutine set_min_varnce_and_mean( Xmean, varnce_X_tol, Xn, varnce_Xn, &
                                      varnce_Xn_out, Xn_out )
! Description:
!   Here we impose a threshold on the variance of a term (usually from the PDF)
!   so as to avoid numerical instability.  If the variance is too small we then
!   set the variable associated with the nth mixture component to the mean
!   value.  E.g., if varnce_rt1 is small we set it to rt_tol^2, then set rt1 = rtm.
! References:
!   None
!-------------------------------------------------------------------------------

    implicit none

    real, intent(in) :: &
      Xmean,            & ! Mean value of variable X             [units vary]
      varnce_X_tol,     & ! Min tolerance on the variance of X   [units vary]
      Xn,               & ! Value of X for the 1st norm. dist.   [units vary]
      varnce_Xn           ! Variance of X for the 2nd norm. dist.[units vary]

    real, intent(out) :: &
      varnce_Xn_out, & ! [units vary]
      Xn_out           ! [units vary]

    ! --- Begin Code ----

    if ( varnce_Xn > varnce_X_tol ) then
      ! The variance is large enough, so we use it.
      varnce_Xn_out = varnce_Xn
      ! Keep X1
      Xn_out = Xn
    else
      ! Set the variance to a small number to prevent a singular matrix
      varnce_Xn_out = varnce_X_tol
      ! Set X to the mean value
      Xn_out = Xmean
    end if

    return
  end subroutine set_min_varnce_and_mean

!-------------------------------------------------------------------------------
  subroutine construct_corr_stw_matrix &
             ( d_variables, corr_array, &
               xp2_on_xm2_array, &
               corr_stw_matrix )
! Description:
!   Construct a correlation matrix containing s,t,w and the lognormal variates.
! References:
!   None.
!-------------------------------------------------------------------------------
    use latin_hypercube_arrays, only: &
      iiLH_s_mellor, & ! Variable(s)
      iiLH_t_mellor, &
      iiLH_w

    use matrix_operations, only: &
      set_lower_triangular_matrix_dp, & ! Procedures
      get_lower_triangular_matrix_sp

    implicit none

    ! External
    intrinsic :: log

    ! Input Variables
    integer, intent(in) :: d_variables ! Number of variates

    real, dimension(d_variables,d_variables), intent(in) :: &
      corr_array ! Correlations between variates

    real, dimension(d_variables), intent(in) :: &
      xp2_on_xm2_array ! x'^2 / xm^2

    ! Output variables
    double precision, dimension(d_variables,d_variables), intent(out) :: &
      corr_stw_matrix ! Correlations between variates with some terms in lognormal space

    ! Local Variables
    real :: &
      corr_st, & ! Correlation for s,t  [-]
      corr_sw, & ! Correlation for w,s  [-]
      corr_tw    ! Correlation for w,t  [-]

    integer :: i, index1, index2, LN_index

    ! ---- Begin Code ----

    ! LN_index is the location of the first variate which is lognormally
    ! distributed (e.g. rain water mixing ratio).
    LN_index = max( iiLH_s_mellor, iiLH_t_mellor, iiLH_w )+1

    corr_stw_matrix = 0.0 ! Initialize to 0

    do i = 1, LN_index-1, 1
      ! Set main diagonal to 1
      corr_stw_matrix(i,i) = 1.0
    end do

    ! Set the correlation of s and t. For this part of the code we assume a
    ! fixed correlation in order to only compute the Cholesky factorization
    ! once per simulation.
    index1 = iiLH_s_mellor
    index2 = iiLH_t_mellor

    call get_lower_triangular_matrix_sp &
         ( d_variables, index1, index2, corr_array, & ! In
            corr_st ) ! Out

    call set_lower_triangular_matrix_dp &
         ( d_variables, index1, index2, dble( corr_st ), & ! In
           corr_stw_matrix ) ! In/out

    ! The correlation between w and s,t is typically not fixed either, but for
    ! the reasons listed above we compute it using a fixed value.
    index1 = iiLH_s_mellor
    index2 = iiLH_w

    call get_lower_triangular_matrix_sp &
         ( d_variables, index1, index2, corr_array, & ! In
            corr_sw ) ! Out
    call set_lower_triangular_matrix_dp &
         ( d_variables, index1, index2, dble( corr_sw ), & ! In
           corr_stw_matrix ) ! In/out

    index1 = iiLH_t_mellor
    index2 = iiLH_w
    if ( corr_sw /= 0 ) then
      ! Approximate the covariance of t and w
      corr_tw = corr_st * corr_sw
    else
      corr_tw = 0.
    end if

    call set_lower_triangular_matrix_dp &
         ( d_variables, index1, index2, dble( corr_tw ), & ! In
           corr_stw_matrix ) ! In/out

    ! Compute the main diagonal for each lognormal variate
    forall ( i = LN_index:d_variables )
      corr_stw_matrix(i,i) = log( 1. + Xp2_on_Xm2_array(i) )
    end forall

    do index1 = LN_index, d_variables
      do index2 = LN_index, index1
        ! Add all lognormal covariances
        call add_corr_to_matrix_LN_LN &
             ( d_variables, index1, index2, & ! In
               xp2_on_xm2_array, corr_array, & ! In
               corr_stw_matrix ) ! In/Out
      end do
    end do

    ! Correlations involving s,t and the lognormal variates
    do index1 = LN_index, d_variables
      call add_corr_to_matrix_gaus_LN &
           ( d_variables, iiLH_s_mellor, &
             iiLH_t_mellor, iiLH_w, index1, &
             xp2_on_xm2_array, corr_array, &
             corr_stw_matrix )
    end do

    return
  end subroutine construct_corr_stw_matrix

!-------------------------------------------------------------------------------
  subroutine add_corr_to_matrix_LN_LN( d_variables, index1, index2, &
                                       xp2_on_xm2_array, corr_array, &
                                       corr_stw_matrix )
! Description:
!   Added a correlation between two lognormally distributed variates to a
!   correlation matrix.
! References:
!   None
!-------------------------------------------------------------------------------
    use matrix_operations, only: &
      get_lower_triangular_matrix_sp, & ! Procedure(s)
      set_lower_triangular_matrix_dp

    implicit none

    ! Input Variables
    integer, intent(in) :: &
      d_variables, & ! Total variates
      index1, index2 ! Index of the 2 variates

    real, dimension(d_variables), intent(in) :: &
      xp2_on_xm2_array ! x'^2 / xm^2 array      [-]

    real, dimension(d_variables,d_variables), intent(in) :: &
      corr_array ! Array of correlations        [-]

    ! Input/Output Variables
    double precision, dimension(d_variables,d_variables), intent(inout) :: &
      corr_stw_matrix ! Correlation matrix      [-]

    ! Local Variables
    real :: &
      corr_xy, & ! Correlation between two variates
      covar_xy   ! Lognormal covariance (not a dimensional covariance)

    ! ---- Begin Code ----

    ! Lognormal covariance between two lognormal variates (e.g. rrain and Nr )

    call get_lower_triangular_matrix_sp &
         ( d_variables, index1, index2, corr_array, & ! In
           corr_xy ) ! Out

    if ( corr_xy /= 0. ) then
      call construct_LN_LN_element &
           ( corr_xy, xp2_on_xm2_array(index1), xp2_on_xm2_array(index2), & ! In
             covar_xy ) ! Out
    else
      covar_xy = 0.
    end if

    call set_lower_triangular_matrix_dp &
         ( d_variables, index1, index2, dble( covar_xy ), & ! In
           corr_stw_matrix ) ! In/out

    return
  end subroutine add_corr_to_matrix_LN_LN

!-------------------------------------------------------------------------------
  subroutine add_corr_to_matrix_gaus_LN( d_variables, iiLH_s_mellor, &
                                         iiLH_t_mellor, iiLH_w, index1, &
                                         xp2_on_xm2_array, corr_array, &
                                         corr_stw_matrix )
! Description:
!   Add a correlation between s,t Mellor, w and a lognormal variate to a
!   correlation matrix.
! References:
!   None
!-------------------------------------------------------------------------------

    use matrix_operations, only: &
      get_lower_triangular_matrix_sp, & ! Procedure(s)
      set_lower_triangular_matrix_dp

    implicit none

    ! Input Variables
    integer, intent(in) :: &
      d_variables, & ! Total variates
      iiLH_s_mellor, & ! Index of s_mellor
      iiLH_t_mellor, & ! Index of t_mellor
      iiLH_w, &        ! Index of w (vertical velocity)
      index1           ! Index of the lognormal variate

    real, dimension(d_variables), intent(in) :: &
      xp2_on_xm2_array ! x'^2 / xm^2 array      [-]

    real, dimension(d_variables,d_variables), intent(in) :: &
      corr_array ! Array of correlations        [-]

    ! Input/Output Variables
    double precision, dimension(d_variables,d_variables), intent(inout) :: &
      corr_stw_matrix ! Correlation matrix      [-]

    ! Local Variables
    real :: &
      corr_sx, &  ! Correlation between s and a lognormal variate
      corr_wx, &  ! Correlation between w and a lognormal variate
      covar_sx, & ! Lognormal covariance of s_mellor and x
      covar_wx    ! Lognormal covariance of w and x

    double precision :: &
      covar_tx    ! Lognormal covariance of t_mellor and x

    ! ---- Begin Code ----

    ! Correlations involving s and lognormal variate x

    call get_lower_triangular_matrix_sp &
         ( d_variables, iiLH_s_mellor, index1, corr_array, & ! In
           corr_sx ) ! Out

    if ( corr_sx /= 0. ) then
      ! Covariance between s and lognormal variate x
      ! The variable x could be rrain, Nr, Nc, et cetera.
      call construct_gaus_LN_element &
           ( corr_sx, 1.0, xp2_on_xm2_array(index1), & ! In
             covar_sx ) ! Out
    else
      covar_sx = 0.
    end if

    call set_lower_triangular_matrix_dp &
         ( d_variables, iiLH_s_mellor, index1, dble( covar_sx ), & ! In
           corr_stw_matrix ) ! In/out

    if ( corr_sx /= 0 ) then
      ! Approximate the covariance of t and x
      ! This formula relies on the fact that iiLH_s_mellor < iiLH_t_mellor
      covar_tx = ( corr_stw_matrix(iiLH_t_mellor,iiLH_s_mellor) * dble( covar_sx ) )
    else
      covar_tx = 0.
    end if

    call set_lower_triangular_matrix_dp &
         ( d_variables, iiLH_t_mellor, index1, covar_tx, & ! In
           corr_stw_matrix ) ! In/out

    ! Correlations involving w and lognormal variate x

    call get_lower_triangular_matrix_sp &
         ( d_variables, iiLH_w, index1, corr_array, & ! In
           corr_wx ) ! Out

    if ( corr_wx /= 0. ) then
      ! Covariance between w and lognormal variate x
      ! The variable x could be rrain, Nr, Nc, et cetera.
      call construct_gaus_LN_element &
           ( corr_wx, 1.0, xp2_on_xm2_array(index1), & ! In
             covar_wx ) ! Out
    else
      covar_wx = 0.
    end if

    call set_lower_triangular_matrix_dp &
         ( d_variables, iiLH_w, index1, dble( covar_wx ), & ! In
           corr_stw_matrix ) ! In/out

    return
  end subroutine add_corr_to_matrix_gaus_LN

!-------------------------------------------------------------------------------
  subroutine add_mu_element_LN( d_variables, index1, xm, xp2_on_xm2, mu1, mu2 )

! Description:
!   Compute an element of mu1 and mu2 for a lognormal variate.

! References:
!   None
!-------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: &
      d_variables, & ! Number of variates
      index1         ! Index of x in mu1 and mu1

    double precision, intent(in) :: &
      Xm ! Mean X  [kg/kg or #/kg]

    real, dimension(d_variables), intent(in) :: & 
      xp2_on_xm2 ! X'^2 / Xm^2 array [-]

    real, dimension(d_variables), intent(inout) :: &
      mu1, mu2 ! Mu 1 and 2     [-]

    double precision :: &
      xp2_on_xm2_element, & ! X'^2 / Xm^2 array [-]
      X1, X2  ! PDF parameter for mean of plume 1 and 2.

    ! ---- Begin Code ----

    xp2_on_xm2_element = dble( xp2_on_xm2(index1) )

    call log_sqd_normalized( Xm, xp2_on_xm2_element, & ! In
                             X1, X2 ) ! Out

    mu1(index1) = real( X1 )
    mu2(index1) = real( X2 )

    return
  end subroutine add_mu_element_LN

  !-----------------------------------------------------------------------------
  pure function corr_LN_to_cov_gaus( corr_xy, sigma_x_gaus, sigma_y_gaus ) &
    result( cov_xy_gaus )
  ! Description:

  ! References:

  !-----------------------------------------------------------------------------

    implicit none

    ! External
    intrinsic :: sqrt, exp, log

    ! Input Variables
    real, intent(in) :: &
      corr_xy,      & ! Correlation of x and y    [-]
      sigma_x_gaus, & ! Normalized std dev of first term 'x' [-]
      sigma_y_gaus    ! Normalized std dev second term 'y'   [-]

    real :: cov_xy_gaus ! Covariance for a gaussian dist. [-]

    ! ---- Begin Code ----

    cov_xy_gaus = log( 1.0 + corr_xy * sqrt( exp( sigma_x_gaus**2 ) - 1.0 ) &
                                     * sqrt( exp( sigma_y_gaus**2 ) - 1.0 ) &
                     )

    return
  end function corr_LN_to_cov_gaus

  !-----------------------------------------------------------------------------
  pure function corr_gaus_LN_to_cov_gaus( corr_sy, sigma_s, sigma_y_gaus ) &
    result( cov_sy_gaus )
  ! Description:

  ! References:

  !-----------------------------------------------------------------------------

    implicit none

    ! External
    intrinsic :: sqrt, exp

    ! Input Variables
    real, intent(in) :: &
      corr_sy,     & ! Correlation of s and y    [-]
      sigma_s,     & ! Normalized std dev of first term (usually Gaussian 's') [units vary]
      sigma_y_gaus   ! Normalized std dev second term 'y'   [-]

    real :: cov_sy_gaus ! Covariance for a gaussian dist. [units vary]

    ! ---- Begin Code ----

    cov_sy_gaus = corr_sy * sigma_s * sqrt( exp( sigma_y_gaus**2 ) - 1.0 )

    return
  end function corr_gaus_LN_to_cov_gaus

  !-----------------------------------------------------------------------------
  pure function mu_LN_to_mu_gaus( mu, sigma2_on_mu2 ) &
    result( mu_gaus )

  ! Description:
  !
  ! References:
  ! 
  !-----------------------------------------------------------------------------

    implicit none

    ! External
    intrinsic :: log

    ! Input Variables
    real, intent(in) :: &
      mu, &         ! Mean term 'x'                     [-]
      sigma2_on_mu2 ! Variance of 'x' over mean 'x'^2   [-]

    real :: mu_gaus ! Mean field converted to gaussian  [-]

    ! ---- Begin Code ----

    mu_gaus = log( mu * ( 1.0 + ( sigma2_on_mu2 ) )**(-0.5) )

    return
  end function mu_LN_to_mu_gaus

  !-----------------------------------------------------------------------------
  pure function sigma_LN_to_sigma_gaus( sigma2_on_mu2 ) result( sigma_gaus )

  ! Description:
  !
  ! References:
  ! 
  !-----------------------------------------------------------------------------

    implicit none

    ! External
    intrinsic :: sqrt, log

    ! Input Variables
    real, intent(in) :: &
      sigma2_on_mu2 ! Variance of 'x' over mean 'x'^2   [-]

    real :: sigma_gaus ! Sigma converted to gaussian dist. [-]

    ! ---- Begin Code ----

    sigma_gaus = sqrt( log( 1.0 + ( sigma2_on_mu2 ) ) )

    return
  end function sigma_LN_to_sigma_gaus

!-----------------------------------------------------------------------------

end module generate_lh_sample_module
