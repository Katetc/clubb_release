%
% $Id: hoc_standards.tex,v 1.4 2008-08-18 17:53:48 dschanen Exp $
%

\documentclass[letterpaper,12pt]{article}
\usepackage{amsmath,amssymb,amsfonts}
%\usepackage{amsfonts}

%% These cannot be interpreted by TTH
\addtolength{\textheight}{2in}\addtolength{\topmargin}{-1in}
\addtolength{\textwidth}{1.25in} \addtolength{\oddsidemargin}{-.75in}
\addtolength{\evensidemargin}{-.75in}

\pagestyle{empty}

\begin{document}

\title{\textbf{Standards and Coding Practices for CLUBB}}
\author{Larson Group UW--Milwaukee}

\maketitle


The following rules apply only to the parts of CLUBB that we have written.  We try not to modify
code from external contributors such as BUGSRad, 
Numerical Recipes, and so forth, because such external code is
less familiar to us, and we might introduce bugs.  Furthermore, our changes would be lost if
we were to update to a new version of the external code.
\newline


%\flushleft
\begin{enumerate}
\item All files in the repository should have a standard header with a SVN 
\texttt{\$Id\$} tag at the top.
\newline
When initially checking in a new source file, enter the Id tag as 
the string \texttt{\$Id\$} on a commented line at the top of the source file
 (SVN will expand this after checking it in).

\bigskip

After checking in the file, something like the following will appear:
\begin{verbatim}
!-----------------------------------------------------------------------
! $Id: hoc_standards.tex,v 1.4 2008-08-18 17:53:48 dschanen Exp $

\end{verbatim}

\item When adding functions and subroutines create a header with a short 
description of their purpose and reference if there is one.  Include 
in the header a description of 
each variable and its respective units.  Use the following standardized
layout: 

\begin{verbatim}
!-----------------------------------------------------------------------
function xyzzy( etherx, ethery, etherz )

! Description:
!   Evaluates the xyzzy function. 

! References:
!   Eqn. 33 on p. 4551 of  
!   Tweedle-dee and Tweedle-dum (1842), J. Imaginary Atmospheric 
!   Sci., Vol. 23, pp. 4550--4556
!-----------------------------------------------------------------------

  ! Included Modules
  use grid_dimensions, only: ndim
 
  implicit none

  ! External Calls
  complex, external :: &
    xyxy_fnc ! (Description of function goes here)

  external :: &
    zyzy_sub ! (Description of subroutine goes here)

  ! It is a good idea to declare intrinsics, in case another 
  ! function or variable is accidentally given the same name.
  intrinsic :: &
    matmul, exp, log, dble

  ! If we had any derived types to declare, then 
  ! we would put them here before the constants.

  ! Local Constants
  real, parameter :: &
    local_tol = 1.0e-6 ! Local tolerance [no units]

  ! Input Variables
  complex, dimension(ndim), intent(in) :: &
    etherx,  ! Ether in the x dimension  [kg/kg]
    ethery,  ! Ether in the y dimension  [kg/kg]
    etherz   ! Ether in the z dimension  [kg/kg]

  ! Output Variables
  complex, dimension(ndim,ndim,ndim) :: &
    xyzzy    ! Ether in the xyyzy dimension  [kg/kg]

  ! Local Variables
  integer :: i, j, k

!-----------------------------------------------------------------------

  !----- Begin Code -----

    ...

  return
end function xyzzy
!-----------------------------------------------------------------------
\end{verbatim}

\item In functions and subroutines put a line with 
\verb|!----- Begin Code -----| after the declarative portion of the code.
This is to make it clear where the algorithmic portion of the procedure starts.

\item Write lots of code comments.  Make sure your code is understandable to an outsider 
looking at it for the first time.  When writing a code comment, leave your name 
at the end of the comment.
This will allow other users to contact you with any questions about the section of code.
Use the same name identifier, e.g. dschanen or Vince Larson, everywhere.
Then everyone can use \texttt{grep} to search for all code comments you've made.

\item Minimize the number of variables or amount of data made available to any 
subroutine in either 
passed arguments or \texttt{use} statements.  Always specify \texttt{intent} 
attributes on your arguments, and use \texttt{intent(in)} 
and \texttt{intent(out)} rather than \texttt{intent(inout)} whenever possible.
This makes the code more clear to new users by allowing them to trace where a 
given variable is changed in the code and spot at a glance what are the inputs and
outputs of each subroutine.  Furthermore,
this makes it easier for the compiler to optimize, because modern computers can 
vectorize floating point instructions, thereby providing some 
parallelization when your calculation does not rely on previous results.
Note however, than an \texttt{intent(out)} variable that is not set in the scope of the subroutine
is \emph{not defined}!  It often preserves the previous value, but it may not.
When using modules with public variables, limit 
the number of variables with an \texttt{only:} statement.  This makes code 
easier to read, because it is then obvious which variables from the module are being 
used.\newline
E.g.
\begin{verbatim}
!-----------------------------------------------------------------------
subroutine mulmul( x, y, z )

! Description:
!   Bogus example

! References:
!   None
!-----------------------------------------------------------------------

  ! Here we limit our use statement to just the needed variables
  use constants, only: &
    pi,         & ! Ratio of radii to their circumferance [no units]
    euler_const   ! Made up constant [no units]

  use dimensions, only: &
    nnzp ! Number of data points of our model [count]

  implicit none

  ! First list input variables
  real, dimension(nnzp), intent(in) :: &
    x, &! First factor   [no units]
    y   ! Second factor  [no units]

  ! Then list inout variables, and then outputs 
  real, dimension(nnzp), intent(out) :: &
    z  ! output         [no units]
!-----------------------------------------------------------------------

  !----- Begin Code -----

  ! Note that every element of z could be calculated 
  ! independently of other elements of the subroutine
  ! allowing for parallelism if possible.

  z(1:nnzp) = ( x(1:nnzp) / pi ) * ( y(1:nnzp) / euler_const )

  return
end subroutine mulmul
!-----------------------------------------------------------------------
\end{verbatim}

\item The general convention in CLUBB is to have the dummy arguments of a subroutine 
ordered with input first, input/output second, and output arguments third. 
The exception to this is optional variables, which must occur last.  In that case,
standard variables should be ordered as above; below this, the optional variables should
be listed with input first, then input/output, and then output variables.
\newline
E.g.
\begin{verbatim}

  ! The wrong way
  subroutine sub( input_variable_1, output_variable_1, &
                  input_variable_2, input_output_variable_1 )

  ! The right way
  subroutine sub( input_variable_1, input_variable_2, &
                  input_output_variable_1, output_variable_1 )

\end{verbatim}

\item Keep on the same lines the arguments of both the originating call and its 
corresponding subroutine declaration.  This makes it easier to check the 
consistency of arguments of subroutines and functions with long argument lists.
\newline 
E.g.
\begin{verbatim}

  ! The wrong way
  call sub( roast_beef, ham, tomato, cheese, &
            lettuce, onion, mayo )

  subroutine sub( roast_beef, ham, &
                  tomato, cheese,  &
                  lettuce, onion, mayo )

   ! The right way
   call sub( roast_beef, ham, tomato, cheese, &
             lettuce, onion, mayo )

   subroutine sub( roast_beef, ham, tomato, cheese, &
                   lettuce, onion, mayo )

\end{verbatim}

\item When breaking up an arithmetic expression over multiple lines, do so according to 
operator precedence.  This makes things more readable at a glance. \newline
E.g. Do this: 
\begin{verbatim}
  x = t + y*x  &
    + g*v + t*h
\end{verbatim}

Not this:
\begin{verbatim}
  x = t + y*x + g &
    *v + t*h
\end{verbatim}

\item Do not use assumed size or assumed shape arrays in CLUBB.  
Generally speaking, the grid class defines the length of model arrays, 
and the use of assumed size arrays introduces 
another level of complexity that can cause bugs.  An exception may occur
if you need to interface with code developed by external contributors that
contains assumed shape arrays.
\newline

\item When a logical expression or a do loop extends more than ten lines, put a
small comment after the end statement with the name of the loop or logical
variable.
E.g. \newline
\begin{verbatim}
  if ( lcode_enabled ) then

    ...many lines of code...

  end if ! lcode_enabled
\end{verbatim}

or 

\begin{verbatim}
  if ( .not. lcode_enabled ) then

    ...many lines of code...

  end if ! ~lcode_enabled
\end{verbatim}

A long do statement

\begin{verbatim}
  do i = 1, 100, 1

  ...many lines of code...

  end do ! i = 1..100
\end{verbatim}

\item When making a logical expression, leave spaces between the 
logical operators and use the Fortran 90 style logical operators. \newline
 E.g.
\begin{verbatim}
  ! Like this
  if ( x == y ) .and. ( y >= z ) .or. ( z /= 0.0 ) then

    ...

  end if

  ! Not like this
  if ( x.eq.y.and.y.ge.z.or.z.ne.0.0 ) then

    ...

  end if

\end{verbatim}

The F90 style operators are:
\newline

\begin{verbatim}
== instead of .eq.
/= instead of .ne.
>  instead of .gt.
>= instead of .ge.
<  instead of .lt.
<= instead of .le.
\end{verbatim}

\item When creating a model flag variable of type \texttt{logical}, precede the
 name with a \verb|l_| to make it easy to see that it is a logical.

\item When writing flow control statements 
(\texttt{ if, else if, select case }), keep the logic as straightforward and
clear as possible.  If a set of \texttt{if...then} expressions grows to more
than three cases, then rewrite the logic as a \texttt{select...case} expression
instead. E.g.

\begin{verbatim}
  ! Rewrite this:
  if ( trim( run ) == "BOMEX" ) then
    execute_stuff( )

  else if ( trim( run ) == "FIRE" ) then
    execute_other_stuff( )

  else if ( trim( run ) == "ARM" ) then
    execute_other_other_stuff( ) 

  else if ( trim( run ) == "DAVE'S_CAMPING_TRIP" ) then
    execute_other_other_other_stuff( ) 

  else
    write(unit=0,fmt=*) "Cannot determine what to do for "//trim( run )

  end if ! run

  ! Like this:
  select case( trim( run ) )
  case( "BOMEX" )
    execute_stuff( )

  case( "FIRE" )
    execute_other_stuff( )

  case( "ARM" )
    execute_other_other_stuff( )
 
  case ( "DAVE'S_CAMPING_TRIP" ) 
    execute_other_other_other_stuff( ) 

  case default
    write(unit=0,fmt=*) "Cannot determine what to do for "//trim( run )

  end select ! run

\end{verbatim}

\item When mixing scalar variables with array variables in a single
mathematical statement, it is often more clear to use indices, even
though Fortran 90 allows you to omit them. \newline
E.g. Do this:

\begin{verbatim}
 xyzzy(1:gr%nnzp) = variable_arr1(1:gr%nnzp) * variable_scl1 &
                    * variable_arr2(1:gr%nnzp)**2
\end{verbatim}

Not this:
\begin{verbatim}
 xyzzy = variable_arr1 * variable_scl1  &
         * variable_arr2**2
\end{verbatim}

\item Use a consistent character case for variables names. 
E.g. if you use \texttt{thlm} in function a, then do not use \texttt{Thlm} in function b. 
This makes the code easier to read and search using your text editor and the 
\texttt{grep} command.
\newline

\item Always use \texttt{implicit none} in your code.  It will make 
debugging much easier, because it prevents the accidental use of 
variables of the wrong type.
\newline

\item When adding a variable that isn't a loop iterator and occurs in more 
than one context, use a variable name that is in some way unique. 
This will make searching for the variable in the code much easier. 
There several ways to do this:
	\begin{enumerate}
	\item Use mixed case.  E.g. \texttt{Rd} for the Dry air gas constant 
	rather than \texttt{R} or \texttt{rd}
	\item Use of a number in the name when the mathematical equations 
	contain them. 
	 E.g. \texttt{p0} for $P_0$.
	\item Use 3 or more characters in the variable name.
	E.g. CLUBB uses \texttt{grav} 
	rather than \texttt{g} or \texttt{gr} for the gravitational constant.
	\end{enumerate}
Avoid using a variable name that overlaps with the text of a reserved word or
Fortran directive as well (e.g. \texttt{inte} overlaps with \texttt{intent} 
and \texttt{integer} and would not be a good variable name).
Try using a command
like \texttt{grep} if you're uncertain if your variable is a semi-unique string.
\newline

\item Do not use the prognostic or diagnostic variable modules anywhere they
are not used already.  Currently the module \texttt{prognostic\_variables} 
is used in 
\texttt{numer\_check} and \texttt{clubb\_driver}, while 
\texttt{diagnostic\_variables} is used in \texttt{clubb\_driver}, 
\texttt{clubb\_core}, 
and \texttt{stats\_subs}. Global variables like these make debugging 
the code more difficult.  The proper way to use these variables in a new 
section of code is to pass them as an argument.
\newline

\item Put all functions and subroutines within a module.  This allows for 
compile time checking of input arguments. \newline

\item When putting several subroutines or functions in a module, limit the
 number of public interfaces to those that are called from outside the 
 module.\\
E.g. 
\begin{verbatim}
  ! module gcss

    ...

  ! Note that all these are subroutines called from 
  ! hoc_forcings_timestep

  public ::
    cloud_rad, atex_tndcy, atex_sfclyr, fire_tndcy, &
    wangara_tndcy, wangara_sfclyr, &
    astex_tndcy, astex_sfclyr, &
    arm_tndcy, arm_sfclyr, &
    bomex_tndcy, bomex_sfclyr, &
    dycoms2_rf01_tndcy, dycoms2_rf01_sfclyr, &
    dycoms2_rf02_tndcy, dycoms2_rf02_sfclyr, &
    nov11_altocu_tndcy 

  ! Note that all these are called from 
  ! subroutines within gcss;  This declaration
  ! makes them unavailable to outside routines

  private ::
    diag_ustar, arm_sfcflx, Diff_denom, &
    altocu_icedf

      ...

\end{verbatim}

\item Good use of whitespace can make code easier to read and debug.  
One simple convention used in CLUBB is to put an extra space between 
parenthesis for functions and subroutines to differentiate them from 
array variables. \newline
E.g.
\begin{verbatim}
  ! Choosing less obscure names for arrays and functions 
  ! will also help with this problem.

  f( x ) ! This is the function f evaluated with argument x.
  f(x)   ! This is the one dimensional array f indexed at x.
\end{verbatim}

This applies to intrinsic functions as well. \newline
E.g.
\begin{verbatim}
  mycalc = exp( x ) * log( y )  &
         + dble( g ) * mod( f, 5 )
\end{verbatim}

\item Code should not make use of explicit precision variables unless there is 
an unique reason for it (e.g. writing 4 byte records to disk).  This allows for 
compile time promotion of reals and doubles on different computer architectures.
Also, do not use the asterisks notation to specify precision, because it
is an extension of the Fortran standard.  E.g.
\begin{verbatim}
  ! This does not allow for compile time promotion.
  real(kind=8) :: x  

  ! This is not standard Fortran and may break.
  real*8 :: x

  ! Everyone will be happy if you keep it like this.
  real :: x ! Marks the spot [deg_E]
\end{verbatim}

\item For clarity, functions, subroutines, modules, and programs should end 
with their proper Fortran 90 style end statement. \newline
E.g.
\begin{verbatim}
  ! Like this
  subroutine foo

     ...

  end subroutine foo

  ! Not like this
  subroutine foo

    ...

  end
\end{verbatim}

\item Separate end statements with a single space. \newline 
E.g.
\begin{verbatim}
  subroutine sub( )

    ...

  do k = 1, gr%nnzp, 1

           ...

  end do ! not 'enddo'

           ...

  where ( rtm < rttol )
    ...
  end where ! not 'endwhere'

  subroutine sub

           ...

    return
  end subroutine sub ! not 'endsubroutine'
\end{verbatim}

% These two items are no longer true since we moved to Free format code -dschanen 6 Aug 08
%\item A convention of CLUBB is to use the exclamation point character \texttt{!} for a comment, rather than a \texttt{C} or a \texttt{*}.  Consistent coding style makes comments easier to spot at a glance.

%\item A convention of CLUBB is to use the period ( \texttt{.} ) as the 
%continuation character.  This gives the code a clean and consistent look.
%e.g.
%\begin{verbatim}
%  function calc_stuff( stuff1, stuff2, &
%                       stuff3, stuff4 )
%\end{verbatim}

\item Use lowercase letters for Fortran keywords. \newline
E.g.
\begin{verbatim}
program HAL ! lowercase program

    ... 

  if ( lTurnOff ) then ! lowercase if, lowercase then

    write(unit=*,fmt=*) "I know that you and Frank were " &
      //"trying to turn me off Dave." ! lowercase write

    stop "Daisy, Daisy..." ! lowercase stop

  end if ! lowercase end, lowercase if

    ...

end program HAL ! lowercase end, lowercase program 
\end{verbatim}

\item For the sake of consistency and code readability, always use a 2 column 
indent after all directives. Also, indent continuation lines by 2 columns. \newline
E.g. \\
\verb|module dynamics| \\
\verb*|  | {\small 2 column indent within the scope of \texttt{module}} \\
\verb|| \\
\verb*|  implicit|\verb| none| \\
\verb|| \\
\verb*|  contains| \\
\verb|| \\
\verb*|  subroutine|\verb| advect_2D( ... )| \\
\verb*|    use|\verb| grid, only: & | {\small 2+2 columns within the scope of \texttt{dynamics/advect\_2D}} \\
\verb*|      nz,|\verb| & | {\small 2+2+2 columns since we're continuing the \texttt{use} statement}  \\
\verb*|      nx| \\
\verb|| \\
\verb*|    if|\verb| ( l_do_something ) then| \\
\verb*|      | {\small 2+2+2 columns within the scope of \texttt{dynamics/advect\_2D/if..then}} \\
\verb|| \\
\verb*|      |\verb|call something( ... )| \\
\verb|| \\
\verb*|    end|\verb| if| \\
\verb|| \\
\verb*|    return| \\
\verb*|  end|\verb| subroutine advect_2D| \\

\verb|end module dynamics|

\item Wrap all code lines at 100 columns.  Fortran free format source code
allows for 132, but the number 100 was chosen to so that we can view the code 
browser without word-wrap on one monitor.

\item Do not use deprecated or obsolescent features of Fortran, and do not
use extensions to the Fortran 95 standard.  This includes but is not limited to
\texttt{pause}, \texttt{equivalence}, Cray style pointers, 
arithmetic \texttt{if}, alternate \texttt{return}, and \texttt{float()} for 
real data type conversions.

\item All files added to the CLUBB code should use a \texttt{.F90} file 
extension.  This is due to the a kluge used with \texttt{mkmf} that only enables
compiler warnings when the file is pre-processed Fortran 90 source. 

\end{enumerate}

\end{document}
